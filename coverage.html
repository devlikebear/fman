
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/devlikebear/fman/cmd/daemon.go (25.0%)</option>
				
				<option value="file1">github.com/devlikebear/fman/cmd/duplicate.go (36.3%)</option>
				
				<option value="file2">github.com/devlikebear/fman/cmd/find.go (77.9%)</option>
				
				<option value="file3">github.com/devlikebear/fman/cmd/organize.go (4.3%)</option>
				
				<option value="file4">github.com/devlikebear/fman/cmd/queue.go (4.7%)</option>
				
				<option value="file5">github.com/devlikebear/fman/cmd/root.go (72.4%)</option>
				
				<option value="file6">github.com/devlikebear/fman/cmd/rules.go (7.8%)</option>
				
				<option value="file7">github.com/devlikebear/fman/cmd/scan.go (51.8%)</option>
				
				<option value="file8">github.com/devlikebear/fman/internal/ai/gemini.go (77.8%)</option>
				
				<option value="file9">github.com/devlikebear/fman/internal/ai/ollama.go (90.9%)</option>
				
				<option value="file10">github.com/devlikebear/fman/internal/daemon/client.go (53.2%)</option>
				
				<option value="file11">github.com/devlikebear/fman/internal/daemon/pathutil.go (90.3%)</option>
				
				<option value="file12">github.com/devlikebear/fman/internal/daemon/queue.go (95.2%)</option>
				
				<option value="file13">github.com/devlikebear/fman/internal/daemon/resource_monitor.go (40.4%)</option>
				
				<option value="file14">github.com/devlikebear/fman/internal/daemon/server.go (77.2%)</option>
				
				<option value="file15">github.com/devlikebear/fman/internal/daemon/types.go (93.8%)</option>
				
				<option value="file16">github.com/devlikebear/fman/internal/daemon/worker.go (93.7%)</option>
				
				<option value="file17">github.com/devlikebear/fman/internal/db/database.go (83.3%)</option>
				
				<option value="file18">github.com/devlikebear/fman/internal/rules/evaluator.go (0.6%)</option>
				
				<option value="file19">github.com/devlikebear/fman/internal/rules/executor.go (2.4%)</option>
				
				<option value="file20">github.com/devlikebear/fman/internal/rules/manager.go (82.2%)</option>
				
				<option value="file21">github.com/devlikebear/fman/internal/scanner/scanner.go (77.2%)</option>
				
				<option value="file22">github.com/devlikebear/fman/internal/utils/paths.go (75.0%)</option>
				
				<option value="file23">github.com/devlikebear/fman/internal/utils/permissions.go (25.0%)</option>
				
				<option value="file24">github.com/devlikebear/fman/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package cmd

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/devlikebear/fman/internal/daemon"
        "github.com/spf13/cobra"
)

// daemonCmd represents the daemon command
var daemonCmd = &amp;cobra.Command{
        Use:   "daemon",
        Short: "Manage the fman background daemon",
        Long: `Manage the fman background daemon that handles asynchronous file scanning operations.

The daemon runs in the background and processes scan requests through a queue system.
It automatically starts when needed and can be managed manually using these commands.`,
}

// daemonStartCmd represents the daemon start command
var daemonStartCmd = &amp;cobra.Command{
        Use:   "start",
        Short: "Start the fman daemon",
        Long: `Start the fman background daemon.

The daemon will run in the background and accept scan requests through Unix domain sockets.
If the daemon is already running, this command will show its current status.`,
        RunE: runDaemonStart,
}

// daemonStopCmd represents the daemon stop command
var daemonStopCmd = &amp;cobra.Command{
        Use:   "stop",
        Short: "Stop the fman daemon",
        Long: `Stop the fman background daemon gracefully.

This will terminate the daemon process and cancel any pending scan operations.
Running scans will be completed before the daemon shuts down.`,
        RunE: runDaemonStop,
}

// daemonStatusCmd represents the daemon status command
var daemonStatusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Show daemon status",
        Long: `Show the current status of the fman background daemon.

This includes information about:
- Whether the daemon is running
- Process ID (PID)
- Socket file location
- Number of jobs in queue
- Daemon uptime and statistics`,
        RunE: runDaemonStatus,
}

// daemonRestartCmd represents the daemon restart command
var daemonRestartCmd = &amp;cobra.Command{
        Use:   "restart",
        Short: "Restart the fman daemon",
        Long: `Restart the fman background daemon.

This will stop the current daemon (if running) and start a new one.
Any pending operations will be preserved in the queue.`,
        RunE: runDaemonRestart,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(daemonCmd)
        daemonCmd.AddCommand(daemonStartCmd)
        daemonCmd.AddCommand(daemonStopCmd)
        daemonCmd.AddCommand(daemonStatusCmd)
        daemonCmd.AddCommand(daemonRestartCmd)
}</span>

// runDaemonStart handles the daemon start command
func runDaemonStart(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        client := daemon.NewDaemonClient(nil)
        defer client.Disconnect()

        // Check if daemon is already running
        if client.IsDaemonRunning() </span><span class="cov0" title="0">{
                fmt.Println("‚úÖ Daemon is already running")
                return runDaemonStatus(cmd, args)
        }</span>

        <span class="cov0" title="0">fmt.Println("üöÄ Starting fman daemon...")

        err := client.StartDaemon()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start daemon: %w", err)
        }</span>

        // Wait a moment for daemon to fully start
        <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)

        // Verify daemon started successfully
        if !client.IsDaemonRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("daemon failed to start properly")
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Daemon started successfully")
        return runDaemonStatus(cmd, args)</span>
}

// runDaemonStop handles the daemon stop command
func runDaemonStop(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        client := daemon.NewDaemonClient(nil)
        defer client.Disconnect()

        // Check if daemon is running
        if !client.IsDaemonRunning() </span><span class="cov0" title="0">{
                fmt.Println("‚ÑπÔ∏è  Daemon is not running")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Println("üõë Stopping fman daemon...")

        err := client.StopDaemon()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop daemon: %w", err)
        }</span>

        // Wait for daemon to shut down
        <span class="cov0" title="0">timeout := time.Now().Add(5 * time.Second)
        for time.Now().Before(timeout) </span><span class="cov0" title="0">{
                if !client.IsDaemonRunning() </span><span class="cov0" title="0">{
                        fmt.Println("‚úÖ Daemon stopped successfully")
                        return nil
                }</span>
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("daemon did not stop within timeout")</span>
}

// runDaemonStatus handles the daemon status command
func runDaemonStatus(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        client := daemon.NewDaemonClient(nil)
        defer client.Disconnect()

        if !client.IsDaemonRunning() </span><span class="cov0" title="0">{
                fmt.Println("‚ùå Daemon is not running")
                return nil
        }</span>

        // Connect to daemon and get status
        <span class="cov0" title="0">err := client.Connect()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("‚ùå Daemon process exists but is not responding")
                return fmt.Errorf("failed to connect to daemon: %w", err)
        }</span>

        <span class="cov0" title="0">status, err := client.GetStatus()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get daemon status: %w", err)
        }</span>

        // Calculate uptime
        <span class="cov0" title="0">uptime := time.Since(status.StartedAt)

        // Display daemon status
        fmt.Println("‚úÖ Daemon is running")
        fmt.Printf("üìç PID: %d\n", status.PID)
        fmt.Printf("‚è∞ Uptime: %s\n", formatDuration(uptime))
        fmt.Printf("üìä Queue Status:\n")
        fmt.Printf("   - Pending: %d jobs\n", status.QueuedJobs)
        fmt.Printf("   - Running: %d jobs\n", status.ActiveJobs)
        fmt.Printf("   - Completed: %d jobs\n", status.CompletedJobs)
        fmt.Printf("   - Failed: %d jobs\n", status.FailedJobs)
        fmt.Printf("üë• Workers: %d active\n", status.Workers)

        return nil</span>
}

// runDaemonRestart handles the daemon restart command
func runDaemonRestart(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        client := daemon.NewDaemonClient(nil)
        defer client.Disconnect()

        wasRunning := client.IsDaemonRunning()

        if wasRunning </span><span class="cov0" title="0">{
                fmt.Println("üõë Stopping current daemon...")
                err := runDaemonStop(cmd, args)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to stop daemon: %w", err)
                }</span>

                // Give it a moment to fully shut down
                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }

        <span class="cov0" title="0">fmt.Println("üöÄ Starting daemon...")
        return runDaemonStart(cmd, args)</span>
}

// ensureDaemonRunning ensures the daemon is running, starting it if necessary
func ensureDaemonRunning() error <span class="cov8" title="1">{
        client := daemon.NewDaemonClient(nil)
        defer client.Disconnect()

        if client.IsDaemonRunning() </span><span class="cov0" title="0">{
                return nil // Already running
        }</span>

        // Start daemon silently
        <span class="cov8" title="1">err := client.StartDaemon()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to auto-start daemon: %w", err)
        }</span>

        // Wait for daemon to start - reduced timeout for tests
        <span class="cov0" title="0">timeout := time.Now().Add(500 * time.Millisecond) // Reduced from 3 seconds
        for time.Now().Before(timeout) </span><span class="cov0" title="0">{
                if client.IsDaemonRunning() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">time.Sleep(50 * time.Millisecond)</span> // Reduced from 100ms
        }

        <span class="cov0" title="0">return fmt.Errorf("daemon auto-start timeout")</span>
}

// formatDuration formats a duration in a human-readable way
func formatDuration(d time.Duration) string <span class="cov8" title="1">{
        if d &lt; time.Minute </span><span class="cov8" title="1">{
                return fmt.Sprintf("%.0fs", d.Seconds())
        }</span>
        <span class="cov8" title="1">if d &lt; time.Hour </span><span class="cov8" title="1">{
                minutes := int(d.Minutes())
                seconds := int(d.Seconds()) - 60*minutes
                return fmt.Sprintf("%dm %ds", minutes, seconds)
        }</span>
        <span class="cov8" title="1">hours := int(d.Hours())
        minutes := int(d.Minutes()) - 60*hours
        return fmt.Sprintf("%dh %dm", hours, minutes)</span>
}

// getPIDFromFile reads PID from the daemon PID file
func getPIDFromFile() (int, error) <span class="cov8" title="1">{
        config := daemon.GetDefaultConfig()
        pidFile := config.PIDPath

        data, err := os.ReadFile(pidFile)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov0" title="0">pid, err := strconv.Atoi(string(data))
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid PID in file: %w", err)
        }</span>

        <span class="cov0" title="0">return pid, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "text/tabwriter"

        "github.com/devlikebear/fman/internal/db"
        "github.com/spf13/cobra"
)

// duplicateCmd represents the duplicate command
var duplicateCmd = &amp;cobra.Command{
        Use:   "duplicate [directory]",
        Short: "Find and manage duplicate files",
        Long: `Find duplicate files by comparing file hashes.
This command scans the database for files with identical content (same hash)
and provides options to review and remove duplicates.

If no directory is specified, searches all indexed files.
If a directory is specified, only searches within that directory.`,
        Args: cobra.MaximumNArgs(1),
        RunE: runDuplicate,
}

var (
        duplicateRemove      bool
        duplicateInteractive bool
        duplicateMinSize     int64
)

func runDuplicate(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize database
        database := db.NewDatabase(nil)
        if err := database.InitDB(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize database: %w", err)
        }</span>
        <span class="cov0" title="0">defer database.Close()

        // Get search directory if specified
        var searchDir string
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                var err error
                searchDir, err = filepath.Abs(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve directory path: %w", err)
                }</span>
        }

        // Find duplicate files
        <span class="cov0" title="0">duplicates, err := findDuplicateFiles(database, searchDir, duplicateMinSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find duplicates: %w", err)
        }</span>

        <span class="cov0" title="0">if len(duplicates) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No duplicate files found.")
                return nil
        }</span>

        // Display results
        <span class="cov0" title="0">totalDuplicates, totalSize := displayDuplicates(duplicates)

        fmt.Printf("\nüìä Summary:\n")
        fmt.Printf("Found %d duplicate file groups\n", len(duplicates))
        fmt.Printf("Total duplicate files: %d\n", totalDuplicates)
        fmt.Printf("Total wasted space: %.2f MB\n", float64(totalSize)/(1024*1024))

        // Handle removal if requested
        if duplicateRemove </span><span class="cov0" title="0">{
                return handleDuplicateRemoval(duplicates, duplicateInteractive)
        }</span>

        <span class="cov0" title="0">fmt.Println("\nUse --remove flag to delete duplicates, or --interactive for selective removal.")
        return nil</span>
}

// DuplicateGroup represents a group of duplicate files
type DuplicateGroup struct {
        Hash  string
        Files []db.File
        Size  int64
}

func findDuplicateFiles(database db.DBInterface, searchDir string, minSize int64) ([]DuplicateGroup, error) <span class="cov8" title="1">{
        // Get all files with hashes
        files, err := database.FindFilesWithHashes(searchDir, minSize)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Group files by hash
        <span class="cov8" title="1">hashGroups := make(map[string][]db.File)
        for _, file := range files </span><span class="cov8" title="1">{
                if file.FileHash != "" </span><span class="cov8" title="1">{
                        hashGroups[file.FileHash] = append(hashGroups[file.FileHash], file)
                }</span>
        }

        // Find groups with more than one file (duplicates)
        <span class="cov8" title="1">var duplicates []DuplicateGroup
        for hash, files := range hashGroups </span><span class="cov8" title="1">{
                if len(files) &gt; 1 </span><span class="cov8" title="1">{
                        // Sort files by path for consistent ordering
                        sort.Slice(files, func(i, j int) bool </span><span class="cov8" title="1">{
                                return files[i].Path &lt; files[j].Path
                        }</span>)

                        <span class="cov8" title="1">duplicates = append(duplicates, DuplicateGroup{
                                Hash:  hash,
                                Files: files,
                                Size:  files[0].Size, // All files in group have same size
                        })</span>
                }
        }

        // Sort duplicate groups by size (largest first)
        <span class="cov8" title="1">sort.Slice(duplicates, func(i, j int) bool </span><span class="cov0" title="0">{
                return duplicates[i].Size &gt; duplicates[j].Size
        }</span>)

        <span class="cov8" title="1">return duplicates, nil</span>
}

func displayDuplicates(duplicates []DuplicateGroup) (int, int64) <span class="cov8" title="1">{
        w := new(tabwriter.Writer)
        w.Init(os.Stdout, 0, 8, 2, '\t', 0)

        totalDuplicates := 0
        totalSize := int64(0)

        for i, group := range duplicates </span><span class="cov8" title="1">{
                fmt.Printf("\nüîç Duplicate Group %d (Hash: %s):\n", i+1, group.Hash[:12]+"...")
                fmt.Printf("File Size: %.2f MB\n", float64(group.Size)/(1024*1024))
                fmt.Printf("Duplicate Count: %d files\n", len(group.Files))
                fmt.Printf("Wasted Space: %.2f MB\n\n", float64(group.Size*(int64(len(group.Files))-1))/(1024*1024))

                fmt.Fprintln(w, "Path\tModified\tDirectory")
                fmt.Fprintln(w, "----\t--------\t---------")

                for _, file := range group.Files </span><span class="cov8" title="1">{
                        dir := filepath.Dir(file.Path)
                        fmt.Fprintf(w, "%s\t%s\t%s\n",
                                file.Path,
                                file.ModifiedAt.Format("2006-01-02 15:04:05"),
                                dir,
                        )
                }</span>
                <span class="cov8" title="1">w.Flush()

                totalDuplicates += len(group.Files)
                totalSize += group.Size * (int64(len(group.Files)) - 1)</span> // Wasted space
        }

        <span class="cov8" title="1">return totalDuplicates, totalSize</span>
}

func handleDuplicateRemoval(duplicates []DuplicateGroup, interactive bool) error <span class="cov0" title="0">{
        fmt.Println("\nüóëÔ∏è  Removing duplicate files...")

        removedCount := 0
        savedSpace := int64(0)

        for i, group := range duplicates </span><span class="cov0" title="0">{
                fmt.Printf("\nProcessing group %d/%d...\n", i+1, len(duplicates))

                if interactive </span><span class="cov0" title="0">{
                        fmt.Printf("Files in this group:\n")
                        for j, file := range group.Files </span><span class="cov0" title="0">{
                                fmt.Printf("  %d. %s (modified: %s)\n", j+1, file.Path,
                                        file.ModifiedAt.Format("2006-01-02 15:04:05"))
                        }</span>

                        <span class="cov0" title="0">fmt.Print("Keep which file? (1-" + fmt.Sprintf("%d", len(group.Files)) + ", or 's' to skip): ")
                        var choice string
                        fmt.Scanln(&amp;choice)

                        if choice == "s" || choice == "S" </span><span class="cov0" title="0">{
                                fmt.Println("Skipped.")
                                continue</span>
                        }

                        // Parse choice and remove others
                        <span class="cov0" title="0">var keepIndex int
                        if _, err := fmt.Sscanf(choice, "%d", &amp;keepIndex); err != nil || keepIndex &lt; 1 || keepIndex &gt; len(group.Files) </span><span class="cov0" title="0">{
                                fmt.Println("Invalid choice, skipping group.")
                                continue</span>
                        }
                        <span class="cov0" title="0">keepIndex-- // Convert to 0-based index

                        // Remove all files except the chosen one
                        for j, file := range group.Files </span><span class="cov0" title="0">{
                                if j != keepIndex </span><span class="cov0" title="0">{
                                        if err := os.Remove(file.Path); err != nil </span><span class="cov0" title="0">{
                                                fmt.Printf("Failed to remove %s: %v\n", file.Path, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                fmt.Printf("Removed: %s\n", file.Path)
                                                removedCount++
                                                savedSpace += group.Size
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Non-interactive: keep the first file (usually oldest), remove others
                        fmt.Printf("Keeping: %s\n", group.Files[0].Path)
                        for j := 1; j &lt; len(group.Files); j++ </span><span class="cov0" title="0">{
                                file := group.Files[j]
                                if err := os.Remove(file.Path); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Failed to remove %s: %v\n", file.Path, err)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("Removed: %s\n", file.Path)
                                        removedCount++
                                        savedSpace += group.Size
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">fmt.Printf("\n‚úÖ Cleanup complete!\n")
        fmt.Printf("Files removed: %d\n", removedCount)
        fmt.Printf("Space saved: %.2f MB\n", float64(savedSpace)/(1024*1024))

        return nil</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(duplicateCmd)

        duplicateCmd.Flags().BoolVar(&amp;duplicateRemove, "remove", false, "Remove duplicate files automatically")
        duplicateCmd.Flags().BoolVar(&amp;duplicateInteractive, "interactive", false, "Interactive mode for selective removal")
        duplicateCmd.Flags().Int64Var(&amp;duplicateMinSize, "min-size", 1024, "Minimum file size in bytes to consider for duplicates")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "text/tabwriter"
        "time"

        "github.com/devlikebear/fman/internal/db"
        "github.com/spf13/cobra"
)

var (
        findSize     string
        findModified string
        findType     string
        findDir      string
)

// findCmd represents the find command
var findCmd = &amp;cobra.Command{
        Use:   "find [name-pattern]",
        Short: "Finds indexed files with advanced search criteria.",
        Long: `Searches the fman database for files using various criteria.
You can search by name pattern, file size, modification date, file type, and directory.

Examples:
  fman find report                    # Find files with 'report' in name
  fman find --size +100M              # Find files larger than 100MB
  fman find --size 1M-10M             # Find files between 1MB and 10MB
  fman find --modified -30d           # Find files modified in last 30 days
  fman find --modified +7d            # Find files older than 7 days
  fman find --type image              # Find image files (.jpg, .png, .gif, etc.)
  fman find --type .pdf               # Find PDF files
  fman find --dir /Users/john/Documents # Find files in specific directory
  fman find report --size +1M --type .pdf # Combined search

Size format: [+/-]&lt;number&gt;[K|M|G] (e.g., +100M, -1G, 500K-2M)
Date format: [+/-]&lt;number&gt;[d|w|m|y] or YYYY-MM-DD (e.g., -30d, +1w, 2024-01-01)
Type format: image|video|audio|document|archive or file extension (e.g., .pdf, .jpg)`,
        Args: cobra.MaximumNArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // Create a new Database instance for each command execution
                dbInstance := db.NewDatabase(nil)
                return runFind(cmd, args, dbInstance)
        }</span>,
}

func runFind(cmd *cobra.Command, args []string, database db.DBInterface) error <span class="cov8" title="1">{
        // Initialize DB
        if err := database.InitDB(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to initialize database: %w", err)
        }</span>
        <span class="cov8" title="1">defer database.Close()

        // Build search criteria
        criteria := db.SearchCriteria{}

        // Name pattern
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                criteria.NamePattern = args[0]
        }</span>

        // Parse size filter
        <span class="cov8" title="1">if findSize != "" </span><span class="cov0" title="0">{
                minSize, maxSize, err := parseSize(findSize)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid size format: %w", err)
                }</span>
                <span class="cov0" title="0">criteria.MinSize = minSize
                criteria.MaxSize = maxSize</span>
        }

        // Parse modified date filter
        <span class="cov8" title="1">if findModified != "" </span><span class="cov0" title="0">{
                after, before, err := parseModified(findModified)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid modified date format: %w", err)
                }</span>
                <span class="cov0" title="0">criteria.ModifiedAfter = after
                criteria.ModifiedBefore = before</span>
        }

        // Parse file type filter
        <span class="cov8" title="1">if findType != "" </span><span class="cov0" title="0">{
                types, err := parseFileType(findType)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid file type: %w", err)
                }</span>
                <span class="cov0" title="0">criteria.FileTypes = types</span>
        }

        // Directory filter
        <span class="cov8" title="1">if findDir != "" </span><span class="cov0" title="0">{
                absDir, err := filepath.Abs(findDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid directory path: %w", err)
                }</span>
                <span class="cov0" title="0">criteria.SearchDir = absDir</span>
        }

        // Search files
        <span class="cov8" title="1">files, err := database.FindFilesByAdvancedCriteria(criteria)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find files: %w", err)
        }</span>

        <span class="cov8" title="1">if len(files) == 0 </span><span class="cov8" title="1">{
                fmt.Println("No files found matching the specified criteria.")
                return nil
        }</span>

        // Print results in a table format
        <span class="cov8" title="1">w := new(tabwriter.Writer)
        w.Init(os.Stdout, 0, 8, 2, '\t', 0)
        fmt.Fprintln(w, "Name\tSize\tModified\tPath")
        fmt.Fprintln(w, "----\t----\t--------\t----")
        for _, file := range files </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "%s\t%s\t%s\t%s\n",
                        file.Name,
                        formatSize(file.Size),
                        file.ModifiedAt.Format("2006-01-02 15:04"),
                        file.Path,
                )
        }</span>
        <span class="cov8" title="1">w.Flush()

        fmt.Printf("\nFound %d file(s)\n", len(files))
        return nil</span>
}

// parseSize parses size filter strings like "+100M", "-1G", "500K-2M"
func parseSize(sizeStr string) (*int64, *int64, error) <span class="cov8" title="1">{
        // Handle range format (e.g., "1M-10M")
        if strings.Contains(sizeStr, "-") &amp;&amp; !strings.HasPrefix(sizeStr, "-") </span><span class="cov8" title="1">{
                parts := strings.Split(sizeStr, "-")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("invalid range format")
                }</span>
                <span class="cov8" title="1">min, err := parseSingleSize(parts[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">max, err := parseSingleSize(parts[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">return &amp;min, &amp;max, nil</span>
        }

        // Handle single size with +/- prefix
        <span class="cov8" title="1">if strings.HasPrefix(sizeStr, "+") </span><span class="cov8" title="1">{
                size, err := parseSingleSize(sizeStr[1:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">return &amp;size, nil, nil</span>
        }

        <span class="cov8" title="1">if strings.HasPrefix(sizeStr, "-") </span><span class="cov8" title="1">{
                size, err := parseSingleSize(sizeStr[1:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">zero := int64(0)
                return &amp;zero, &amp;size, nil</span>
        }

        // Handle exact size
        <span class="cov8" title="1">size, err := parseSingleSize(sizeStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return &amp;size, &amp;size, nil</span>
}

// parseSingleSize parses a single size string like "100M", "1G", "500K"
func parseSingleSize(sizeStr string) (int64, error) <span class="cov8" title="1">{
        re := regexp.MustCompile(`^(\d+(?:\.\d+)?)(K|M|G|B)?$`)
        matches := re.FindStringSubmatch(strings.ToUpper(sizeStr))
        if len(matches) == 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid size format: %s", sizeStr)
        }</span>

        <span class="cov8" title="1">num, err := strconv.ParseFloat(matches[1], 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">unit := matches[2]
        switch unit </span>{
        case "K":<span class="cov8" title="1">
                return int64(num * 1024), nil</span>
        case "M":<span class="cov8" title="1">
                return int64(num * 1024 * 1024), nil</span>
        case "G":<span class="cov8" title="1">
                return int64(num * 1024 * 1024 * 1024), nil</span>
        case "B", "":<span class="cov8" title="1">
                return int64(num), nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unknown size unit: %s", unit)</span>
        }
}

// parseModified parses modified date filter strings like "-30d", "+1w", "2024-01-01"
func parseModified(modStr string) (*time.Time, *time.Time, error) <span class="cov8" title="1">{
        now := time.Now()

        // Handle relative dates with +/- prefix
        if strings.HasPrefix(modStr, "+") || strings.HasPrefix(modStr, "-") </span><span class="cov8" title="1">{
                isOlder := strings.HasPrefix(modStr, "+")
                durStr := modStr[1:]

                duration, err := parseRelativeDuration(durStr)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">if isOlder </span><span class="cov8" title="1">{
                        // Files older than duration
                        cutoff := now.Add(-duration)
                        return nil, &amp;cutoff, nil
                }</span> else<span class="cov8" title="1"> {
                        // Files newer than duration
                        cutoff := now.Add(-duration)
                        return &amp;cutoff, nil, nil
                }</span>
        }

        // Handle absolute date (YYYY-MM-DD)
        <span class="cov8" title="1">date, err := time.Parse("2006-01-02", modStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("invalid date format, use YYYY-MM-DD or relative format like -30d")
        }</span>

        // Return files from that specific day
        <span class="cov8" title="1">start := date
        end := date.Add(24 * time.Hour)
        return &amp;start, &amp;end, nil</span>
}

// parseRelativeDuration parses duration strings like "30d", "1w", "2m", "1y"
func parseRelativeDuration(durStr string) (time.Duration, error) <span class="cov8" title="1">{
        re := regexp.MustCompile(`^(\d+)(d|w|m|y)$`)
        matches := re.FindStringSubmatch(strings.ToLower(durStr))
        if len(matches) == 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid duration format: %s", durStr)
        }</span>

        <span class="cov8" title="1">num, err := strconv.Atoi(matches[1])
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">unit := matches[2]
        switch unit </span>{
        case "d":<span class="cov8" title="1">
                return time.Duration(num) * 24 * time.Hour, nil</span>
        case "w":<span class="cov8" title="1">
                return time.Duration(num) * 7 * 24 * time.Hour, nil</span>
        case "m":<span class="cov8" title="1">
                return time.Duration(num) * 30 * 24 * time.Hour, nil</span>
        case "y":<span class="cov8" title="1">
                return time.Duration(num) * 365 * 24 * time.Hour, nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unknown duration unit: %s", unit)</span>
        }
}

// parseFileType parses file type filter strings
func parseFileType(typeStr string) ([]string, error) <span class="cov8" title="1">{
        typeStr = strings.ToLower(typeStr)

        // Handle predefined types
        switch typeStr </span>{
        case "image":<span class="cov8" title="1">
                return []string{".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp", ".svg"}, nil</span>
        case "video":<span class="cov8" title="1">
                return []string{".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm", ".m4v"}, nil</span>
        case "audio":<span class="cov0" title="0">
                return []string{".mp3", ".wav", ".flac", ".aac", ".ogg", ".wma", ".m4a"}, nil</span>
        case "document":<span class="cov8" title="1">
                return []string{".pdf", ".doc", ".docx", ".txt", ".rtf", ".odt", ".pages"}, nil</span>
        case "archive":<span class="cov0" title="0">
                return []string{".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz"}, nil</span>
        default:<span class="cov8" title="1">
                // Handle specific extension
                if strings.HasPrefix(typeStr, ".") </span><span class="cov8" title="1">{
                        return []string{typeStr}, nil
                }</span>
                // Try to add dot prefix
                <span class="cov8" title="1">return []string{"." + typeStr}, nil</span>
        }
}

// formatSize formats file size in human-readable format
func formatSize(bytes int64) string <span class="cov8" title="1">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov8" title="1">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(findCmd)

        // Add flags for advanced search
        findCmd.Flags().StringVar(&amp;findSize, "size", "", "Filter by file size (e.g., +100M, -1G, 500K-2M)")
        findCmd.Flags().StringVar(&amp;findModified, "modified", "", "Filter by modification date (e.g., -30d, +1w, 2024-01-01)")
        findCmd.Flags().StringVar(&amp;findType, "type", "", "Filter by file type (image, video, audio, document, archive, .pdf, .jpg)")
        findCmd.Flags().StringVar(&amp;findDir, "dir", "", "Search within specific directory")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package cmd

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/devlikebear/fman/internal/ai"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        NewGeminiProvider func() ai.AIProvider = ai.NewGeminiProvider
        NewOllamaProvider func() ai.AIProvider = ai.NewOllamaProvider
)

// organizeCmd represents the organize command
var organizeCmd = &amp;cobra.Command{
        Use:   "organize &lt;directory&gt;",
        Short: "Organizes files in a directory, with suggestions from AI.",
        Long: `Organizes files within a specified directory. 
When used with the --ai flag, it leverages an AI provider (like Gemini or Ollama)
to get suggestions for how to best organize the files. It then presents the suggested
shell commands to the user for approval before executing them.`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                aiFlag, _ := cmd.Flags().GetBool("ai")
                if !aiFlag </span><span class="cov0" title="0">{
                        return fmt.Errorf("the --ai flag is required to use AI-based organization")
                }</span>

                <span class="cov0" title="0">providerName := viper.GetString("ai_provider")
                var provider ai.AIProvider

                switch providerName </span>{
                case "gemini":<span class="cov0" title="0">
                        provider = NewGeminiProvider()</span>
                case "ollama":<span class="cov0" title="0">
                        provider = NewOllamaProvider()</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unknown AI provider: %s. Please check your config file", providerName)</span>
                }

                <span class="cov0" title="0">return runOrganize(cmd, args, fileSystem, provider)</span>
        },
}

func runOrganize(cmd *cobra.Command, args []string, fs afero.Fs, provider ai.AIProvider) error <span class="cov0" title="0">{
        dir := args[0]
        fmt.Printf("Getting AI suggestions to organize directory: %s (using %s)\n", dir, provider.String())

        var filePaths []string
        entries, err := afero.ReadDir(fs, dir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read directory: %w", err)
        }</span>
        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        filePaths = append(filePaths, filepath.Join(dir, entry.Name()))
                }</span>
        }

        <span class="cov0" title="0">if len(filePaths) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No files to organize in the specified directory.")
                return nil
        }</span>

        <span class="cov0" title="0">suggestions, err := provider.SuggestOrganization(context.Background(), filePaths)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get suggestions from AI provider: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("\nAI-suggested commands:")
        fmt.Println("------------------------")
        fmt.Println(suggestions)
        fmt.Println("------------------------")
        fmt.Print("Do you want to execute these commands? (y/n): ")

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read user input: %w", err)
        }</span>

        <span class="cov0" title="0">if strings.ToLower(strings.TrimSpace(response)) == "y" </span><span class="cov0" title="0">{
                fmt.Println("Executing commands...")
                // We will execute the script in the context of the target directory
                cmd := exec.Command("bash", "-c", suggestions)
                cmd.Dir = dir // Run the command in the directory we are organizing
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute suggested commands: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("Commands executed successfully.")</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("Organization cancelled.")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(organizeCmd)
        organizeCmd.Flags().Bool("ai", false, "Use AI to get organization suggestions")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package cmd

import (
        "fmt"
        "text/tabwriter"
        "time"

        "github.com/devlikebear/fman/internal/daemon"
        "github.com/spf13/cobra"
)

// queueCmd represents the queue command
var queueCmd = &amp;cobra.Command{
        Use:   "queue",
        Short: "Manage background scan queue",
        Long: `Manage the background scan queue. You can list jobs, check status, 
cancel jobs, and clear completed jobs.

Available subcommands:
  list    - List all jobs in the queue
  status  - Check status of a specific job
  cancel  - Cancel a pending or running job
  clear   - Clear completed and failed jobs`,
}

// queueListCmd represents the queue list command
var queueListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all jobs in the queue",
        Long: `List all jobs in the queue with their status, creation time, and other details.
Shows jobs in all states: pending, running, completed, failed, and cancelled.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runQueueList(cmd, args)
        }</span>,
}

// queueStatusCmd represents the queue status command
var queueStatusCmd = &amp;cobra.Command{
        Use:   "status &lt;job-id&gt;",
        Short: "Check status of a specific job",
        Long: `Check the detailed status of a specific job by its ID.
Shows job progress, statistics, and any error messages.`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runQueueStatus(cmd, args)
        }</span>,
}

// queueCancelCmd represents the queue cancel command
var queueCancelCmd = &amp;cobra.Command{
        Use:   "cancel &lt;job-id&gt;",
        Short: "Cancel a pending or running job",
        Long: `Cancel a job that is currently pending or running.
Completed jobs cannot be cancelled.`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runQueueCancel(cmd, args)
        }</span>,
}

// queueClearCmd represents the queue clear command
var queueClearCmd = &amp;cobra.Command{
        Use:   "clear",
        Short: "Clear completed and failed jobs",
        Long: `Clear all completed and failed jobs from the queue.
This helps keep the queue clean and reduces memory usage.
Pending and running jobs are not affected.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runQueueClear(cmd, args)
        }</span>,
}

func runQueueList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Create daemon client
        client := daemon.NewDaemonClient(nil)

        // Connect to daemon
        err := client.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to daemon: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Disconnect()

        // Get all jobs
        jobs, err := client.ListJobs("")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list jobs: %w", err)
        }</span>

        <span class="cov0" title="0">if len(jobs) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No jobs in queue.")
                return nil
        }</span>

        // Create tabwriter for aligned output
        <span class="cov0" title="0">w := tabwriter.NewWriter(cmd.OutOrStdout(), 0, 0, 2, ' ', 0)
        defer w.Flush()

        // Print header
        fmt.Fprintln(w, "Job ID\tStatus\tPath\tCreated\tDuration")
        fmt.Fprintln(w, "------\t------\t----\t-------\t--------")

        // Print jobs
        for _, job := range jobs </span><span class="cov0" title="0">{
                duration := formatJobDuration(job)
                status := formatJobStatus(job.Status)

                // Truncate path if too long
                path := job.Path
                if len(path) &gt; 50 </span><span class="cov0" title="0">{
                        path = "..." + path[len(path)-47:]
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\n",
                        job.ID[:8]+"...", // Show first 8 characters of ID
                        status,
                        path,
                        job.CreatedAt.Format("15:04:05"),
                        duration,
                )</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func runQueueStatus(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        jobID := args[0]

        // Create daemon client
        client := daemon.NewDaemonClient(nil)

        // Connect to daemon
        err := client.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to daemon: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Disconnect()

        // Get job details
        job, err := client.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get job status: %w", err)
        }</span>

        // Print job details
        <span class="cov0" title="0">fmt.Printf("üÜî Job ID: %s\n", job.ID)
        fmt.Printf("üìÅ Path: %s\n", job.Path)
        fmt.Printf("üìä Status: %s\n", formatJobStatus(job.Status))
        fmt.Printf("‚è∞ Created: %s\n", job.CreatedAt.Format("2006-01-02 15:04:05"))

        if job.StartedAt != nil </span><span class="cov0" title="0">{
                fmt.Printf("üöÄ Started: %s\n", job.StartedAt.Format("2006-01-02 15:04:05"))
        }</span>

        <span class="cov0" title="0">if job.CompletedAt != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ Completed: %s\n", job.CompletedAt.Format("2006-01-02 15:04:05"))
        }</span>

        <span class="cov0" title="0">duration := formatJobDuration(job)
        if duration != "-" </span><span class="cov0" title="0">{
                fmt.Printf("‚è±Ô∏è  Duration: %s\n", duration)
        }</span>

        // Show progress if available
        <span class="cov0" title="0">if job.Progress != nil </span><span class="cov0" title="0">{
                fmt.Printf("üìà Progress: %d files processed\n", job.Progress.FilesProcessed)
                if job.Progress.CurrentPath != "" </span><span class="cov0" title="0">{
                        fmt.Printf("üìÇ Current: %s\n", job.Progress.CurrentPath)
                }</span>
        }

        // Show statistics if available
        <span class="cov0" title="0">if job.Stats != nil </span><span class="cov0" title="0">{
                fmt.Printf("\nüìä Statistics:\n")
                fmt.Printf("  ‚úÖ Files indexed: %d\n", job.Stats.FilesIndexed)
                fmt.Printf("  ‚è≠Ô∏è  Directories skipped: %d\n", job.Stats.DirectoriesSkipped)
                fmt.Printf("  ‚ö†Ô∏è  Permission errors: %d\n", job.Stats.PermissionErrors)
        }</span>

        // Show error if any
        <span class="cov0" title="0">if job.Error != "" </span><span class="cov0" title="0">{
                fmt.Printf("\n‚ùå Error: %s\n", job.Error)
        }</span>

        // Show options
        <span class="cov0" title="0">if job.Options != nil </span><span class="cov0" title="0">{
                fmt.Printf("\n‚öôÔ∏è  Options:\n")
                fmt.Printf("  Verbose: %t\n", job.Options.Verbose)
                fmt.Printf("  Force Sudo: %t\n", job.Options.ForceSudo)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runQueueCancel(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        jobID := args[0]

        // Create daemon client
        client := daemon.NewDaemonClient(nil)

        // Connect to daemon
        err := client.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to daemon: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Disconnect()

        // Cancel job
        err = client.CancelJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cancel job: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Job %s has been cancelled\n", jobID)
        return nil</span>
}

func runQueueClear(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Create daemon client
        client := daemon.NewDaemonClient(nil)

        // Connect to daemon
        err := client.Connect()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to daemon: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Disconnect()

        // Clear queue
        err = client.ClearQueue()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear queue: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Queue cleared successfully")
        return nil</span>
}

// Helper functions
func formatJobStatus(status daemon.JobStatus) string <span class="cov0" title="0">{
        switch status </span>{
        case daemon.JobStatusPending:<span class="cov0" title="0">
                return "‚è≥ Pending"</span>
        case daemon.JobStatusRunning:<span class="cov0" title="0">
                return "üîÑ Running"</span>
        case daemon.JobStatusCompleted:<span class="cov0" title="0">
                return "‚úÖ Completed"</span>
        case daemon.JobStatusFailed:<span class="cov0" title="0">
                return "‚ùå Failed"</span>
        case daemon.JobStatusCancelled:<span class="cov0" title="0">
                return "‚õî Cancelled"</span>
        default:<span class="cov0" title="0">
                return string(status)</span>
        }
}

func formatJobDuration(job *daemon.Job) string <span class="cov0" title="0">{
        if job.StartedAt == nil </span><span class="cov0" title="0">{
                return "-"
        }</span>

        <span class="cov0" title="0">endTime := time.Now()
        if job.CompletedAt != nil </span><span class="cov0" title="0">{
                endTime = *job.CompletedAt
        }</span>

        <span class="cov0" title="0">duration := endTime.Sub(*job.StartedAt)

        if duration &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%ds", int(duration.Seconds()))
        }</span> else<span class="cov0" title="0"> if duration &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm%ds", int(duration.Minutes()), int(duration.Seconds())%60)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%dh%dm", int(duration.Hours()), int(duration.Minutes())%60)
        }</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(queueCmd)

        // Add subcommands
        queueCmd.AddCommand(queueListCmd)
        queueCmd.AddCommand(queueStatusCmd)
        queueCmd.AddCommand(queueCancelCmd)
        queueCmd.AddCommand(queueClearCmd)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package cmd

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/spf13/afero"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// fileSystem is the filesystem abstraction, defaults to osFs
var fileSystem = afero.NewOsFs()

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "fman",
        Short: "fman is a powerful CLI tool to manage your local files intelligently with AI.",
        Long: `fman (File Manager) is a command-line interface (CLI) tool developed in Go.
It helps you organize and manage local files intelligently, utilizing AI to suggest
and perform file operations.`,
        PersistentPreRun: func(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
                // Auto-start daemon for commands that need it (except daemon commands themselves)
                if cmd.Name() != "daemon" &amp;&amp; cmd.Parent() != nil &amp;&amp; cmd.Parent().Name() != "daemon" </span><span class="cov0" title="0">{
                        // Silently try to ensure daemon is running
                        // We don't want to fail the command if daemon auto-start fails
                        _ = ensureDaemonRunning()
                }</span>
        },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)
}</span>

// initConfig reads in config file and ENV variables if set.
func initConfig() <span class="cov8" title="1">{
        // Find home directory.
        home, err := os.UserHomeDir()
        cobra.CheckErr(err)

        configPath := filepath.Join(home, ".fman")
        configName := "config"
        configType := "yml"
        configFile := filepath.Join(configPath, fmt.Sprintf("%s.%s", configName, configType))

        viper.AddConfigPath(configPath)
        viper.SetConfigName(configName)
        viper.SetConfigType(configType)

        viper.AutomaticEnv() // read in environment variables that match

        // If a config file is found, read it in.
        if err := viper.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                // If config file not found, create it
                if _, ok := err.(viper.ConfigFileNotFoundError); ok </span><span class="cov8" title="1">{
                        if err := os.MkdirAll(configPath, os.ModePerm); err != nil </span><span class="cov8" title="1">{
                                fmt.Fprintf(os.Stderr, "Error creating config directory: %s\n", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov8" title="1">defaultConfig := `# ~/.fman/config.yml
# ÏÇ¨Ïö©Ìï† AI Í≥µÍ∏âÏûêÎ•º ÏÑ†ÌÉùÌï©ÎãàÎã§. (gemini ÎòêÎäî ollama)
ai_provider: "gemini"

gemini:
  # Gemini API ÌÇ§Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.
  api_key: "YOUR_GEMINI_API_KEY"
  # ÏÇ¨Ïö©Ìï† Î™®Îç∏ÏùÑ ÏßÄÏ†ïÌï©ÎãàÎã§.
  model: "gemini-1.5-flash"

ollama:
  # Ollama ÏÑúÎ≤Ñ Ï£ºÏÜåÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.
  base_url: "http://localhost:11434"
  # ÏÇ¨Ïö©Ìï† Î™®Îç∏ÏùÑ ÏßÄÏ†ïÌï©ÎãàÎã§.
  model: "llama3"
`
                        if err := os.WriteFile(configFile, []byte(defaultConfig), 0644); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error creating config file: %s\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov8" title="1">fmt.Println("Configuration file created at:", configFile)
                        fmt.Println("Please edit it to add your API key.")</span>

                } else<span class="cov0" title="0"> {
                        // Config file was found but another error was produced
                        fmt.Fprintf(os.Stderr, "Error reading config file: %s\n", err)
                        os.Exit(1)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/tabwriter"
        "time"

        "github.com/devlikebear/fman/internal/db"
        "github.com/devlikebear/fman/internal/rules"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        rulesVerbose bool
        rulesDryRun  bool
        rulesConfirm bool
        rulesDir     string
)

// Helper function to get config directory
func getConfigDir() string <span class="cov0" title="0">{
        configDir := viper.GetString("config_dir")
        if configDir == "" </span><span class="cov0" title="0">{
                homeDir, _ := os.UserHomeDir()
                configDir = filepath.Join(homeDir, ".fman")
        }</span>
        <span class="cov0" title="0">return configDir</span>
}

// rulesCmd represents the rules command
var rulesCmd = &amp;cobra.Command{
        Use:   "rules",
        Short: "Manage file organization rules",
        Long: `Manage file organization rules for automated file management.

Rules allow you to define conditions and actions for automatic file organization.
For example, you can create rules to move old screenshots to an archive folder,
or delete temporary files that are larger than a certain size.

Available subcommands:
  list     - List all rules
  add      - Add a new rule (interactive)
  remove   - Remove a rule
  apply    - Apply rules to files
  enable   - Enable a rule
  disable  - Disable a rule
  init     - Initialize with example rules

Examples:
  fman rules list                    # List all rules
  fman rules apply --dry-run         # Preview what rules would do
  fman rules apply ~/Downloads       # Apply rules to Downloads folder
  fman rules enable screenshot-rule  # Enable a specific rule
  fman rules init                    # Create example rules`,
}

// rulesListCmd represents the rules list command
var rulesListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all rules",
        Long:  `List all file organization rules with their status and descriptions.`,
        RunE:  runRulesList,
}

// rulesApplyCmd represents the rules apply command
var rulesApplyCmd = &amp;cobra.Command{
        Use:   "apply [directory]",
        Short: "Apply rules to organize files",
        Long: `Apply enabled rules to organize files in the specified directory.
If no directory is specified, applies to all indexed files.

The --dry-run flag allows you to preview what actions would be taken
without actually modifying any files.`,
        RunE: runRulesApply,
}

// rulesRemoveCmd represents the rules remove command
var rulesRemoveCmd = &amp;cobra.Command{
        Use:   "remove &lt;rule-name&gt;",
        Short: "Remove a rule",
        Long:  `Remove a file organization rule by name.`,
        Args:  cobra.ExactArgs(1),
        RunE:  runRulesRemove,
}

// rulesEnableCmd represents the rules enable command
var rulesEnableCmd = &amp;cobra.Command{
        Use:   "enable &lt;rule-name&gt;",
        Short: "Enable a rule",
        Long:  `Enable a file organization rule by name.`,
        Args:  cobra.ExactArgs(1),
        RunE:  runRulesEnable,
}

// rulesDisableCmd represents the rules disable command
var rulesDisableCmd = &amp;cobra.Command{
        Use:   "disable &lt;rule-name&gt;",
        Short: "Disable a rule",
        Long:  `Disable a file organization rule by name.`,
        Args:  cobra.ExactArgs(1),
        RunE:  runRulesDisable,
}

// rulesInitCmd represents the rules init command
var rulesInitCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize with example rules",
        Long:  `Create example file organization rules to get started.`,
        RunE:  runRulesInit,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(rulesCmd)

        // Add subcommands
        rulesCmd.AddCommand(rulesListCmd)
        rulesCmd.AddCommand(rulesApplyCmd)
        rulesCmd.AddCommand(rulesRemoveCmd)
        rulesCmd.AddCommand(rulesEnableCmd)
        rulesCmd.AddCommand(rulesDisableCmd)
        rulesCmd.AddCommand(rulesInitCmd)

        // Add flags
        rulesApplyCmd.Flags().BoolVar(&amp;rulesDryRun, "dry-run", false, "Preview actions without executing them")
        rulesApplyCmd.Flags().BoolVarP(&amp;rulesVerbose, "verbose", "v", false, "Verbose output")
        rulesApplyCmd.Flags().BoolVar(&amp;rulesConfirm, "confirm", false, "Ask for confirmation before each action")
        rulesApplyCmd.Flags().StringVar(&amp;rulesDir, "dir", "", "Apply rules only to files in this directory")

        rulesListCmd.Flags().BoolVarP(&amp;rulesVerbose, "verbose", "v", false, "Show detailed rule information")
}</span>

// runRulesList lists all rules
func runRulesList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        manager := rules.NewManager(getConfigDir())
        if err := manager.LoadRules(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load rules: %w", err)
        }</span>

        <span class="cov0" title="0">allRules := manager.GetRules()
        if len(allRules) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No rules found. Use 'fman rules init' to create example rules.")
                return nil
        }</span>

        // Create table writer
        <span class="cov0" title="0">w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        defer w.Flush()

        if rulesVerbose </span><span class="cov0" title="0">{
                fmt.Fprintln(w, "NAME\tSTATUS\tCONDITIONS\tACTIONS\tDESCRIPTION\tUPDATED")
                fmt.Fprintln(w, "----\t------\t----------\t-------\t-----------\t-------")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintln(w, "NAME\tSTATUS\tDESCRIPTION")
                fmt.Fprintln(w, "----\t------\t-----------")
        }</span>

        <span class="cov0" title="0">for _, rule := range allRules </span><span class="cov0" title="0">{
                status := "disabled"
                if rule.Enabled </span><span class="cov0" title="0">{
                        status = "enabled"
                }</span>

                <span class="cov0" title="0">if rulesVerbose </span><span class="cov0" title="0">{
                        conditionsStr := fmt.Sprintf("%d conditions", len(rule.Conditions))
                        actionsStr := fmt.Sprintf("%d actions", len(rule.Actions))
                        updatedStr := rule.UpdatedAt.Format("2006-01-02")

                        fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%s\n",
                                rule.Name, status, conditionsStr, actionsStr, rule.Description, updatedStr)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(w, "%s\t%s\t%s\n", rule.Name, status, rule.Description)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// runRulesApply applies rules to organize files
func runRulesApply(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize database
        database := db.NewDatabase(nil)

        // Load rules
        manager := rules.NewManager(getConfigDir())
        if err := manager.LoadRules(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load rules: %w", err)
        }</span>

        <span class="cov0" title="0">enabledRules := manager.GetEnabledRules()
        if len(enabledRules) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No enabled rules found. Use 'fman rules list' to see available rules.")
                return nil
        }</span>

        // Determine target directory
        <span class="cov0" title="0">targetDir := ""
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                targetDir = args[0]
        }</span>
        <span class="cov0" title="0">if rulesDir != "" </span><span class="cov0" title="0">{
                targetDir = rulesDir
        }</span>

        // Get files to process
        <span class="cov0" title="0">var files []db.File
        var err error

        if targetDir != "" </span><span class="cov0" title="0">{
                // Expand relative path
                absDir, err := filepath.Abs(targetDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve directory path: %w", err)
                }</span>

                // Find files in the specified directory using pattern matching
                <span class="cov0" title="0">criteria := db.SearchCriteria{
                        NamePattern: "",
                }

                // Get all files and filter by path
                allFiles, err := database.FindFilesByAdvancedCriteria(criteria)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find files: %w", err)
                }</span>

                // Filter files by directory
                <span class="cov0" title="0">for _, file := range allFiles </span><span class="cov0" title="0">{
                        if strings.HasPrefix(file.Path, absDir) </span><span class="cov0" title="0">{
                                files = append(files, file)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Get all indexed files
                criteria := db.SearchCriteria{
                        NamePattern: "", // Empty pattern to get all files
                }
                files, err = database.FindFilesByAdvancedCriteria(criteria)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get files: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No files found to process.")
                return nil
        }</span>

        // Initialize evaluator and executor
        <span class="cov0" title="0">evaluator := rules.NewEvaluator(rulesVerbose)
        executor := rules.NewExecutor(rulesDryRun, rulesVerbose, rulesConfirm)

        // Track execution summary
        summary := rules.ExecutionSummary{
                TotalFiles: len(files),
                Results:    []rules.ExecutionResult{},
                Errors:     []error{},
        }
        start := time.Now()

        fmt.Printf("Processing %d files with %d enabled rules...\n", len(files), len(enabledRules))
        if rulesDryRun </span><span class="cov0" title="0">{
                fmt.Println("DRY RUN MODE - No files will be modified")
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // Process each file
        for _, file := range files </span><span class="cov0" title="0">{
                processed := false

                // Check each rule
                for _, rule := range enabledRules </span><span class="cov0" title="0">{
                        matches, err := evaluator.EvaluateRule(rule, file, targetDir)
                        if err != nil </span><span class="cov0" title="0">{
                                summary.Errors = append(summary.Errors, fmt.Errorf("rule '%s': %w", rule.Name, err))
                                continue</span>
                        }

                        <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
                                if rulesVerbose </span><span class="cov0" title="0">{
                                        fmt.Printf("File %s matches rule '%s'\n", file.Path, rule.Name)
                                }</span>

                                // Execute the rule
                                <span class="cov0" title="0">result := executor.ExecuteRule(rule, file, targetDir)
                                summary.Results = append(summary.Results, result)

                                if result.Success </span><span class="cov0" title="0">{
                                        summary.SuccessfulActions += len(result.Actions)
                                        processed = true
                                }</span> else<span class="cov0" title="0"> {
                                        summary.FailedActions += len(result.Actions)
                                        if result.Error != nil </span><span class="cov0" title="0">{
                                                summary.Errors = append(summary.Errors, result.Error)
                                        }</span>
                                }

                                // Count skipped actions
                                <span class="cov0" title="0">for _, action := range result.Actions </span><span class="cov0" title="0">{
                                        if action.Skipped </span><span class="cov0" title="0">{
                                                summary.SkippedActions++
                                        }</span>
                                }

                                <span class="cov0" title="0">break</span> // Only apply the first matching rule per file
                        }
                }

                <span class="cov0" title="0">if processed </span><span class="cov0" title="0">{
                        summary.ProcessedFiles++
                }</span>
        }

        <span class="cov0" title="0">summary.Duration = time.Since(start)

        // Print summary
        fmt.Println()
        fmt.Println("=== Execution Summary ===")
        fmt.Printf("Total files: %d\n", summary.TotalFiles)
        fmt.Printf("Processed files: %d\n", summary.ProcessedFiles)
        fmt.Printf("Successful actions: %d\n", summary.SuccessfulActions)
        fmt.Printf("Failed actions: %d\n", summary.FailedActions)
        fmt.Printf("Skipped actions: %d\n", summary.SkippedActions)
        fmt.Printf("Duration: %v\n", summary.Duration)

        if len(summary.Errors) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nErrors encountered:\n")
                for _, err := range summary.Errors </span><span class="cov0" title="0">{
                        fmt.Printf("  - %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// runRulesRemove removes a rule
func runRulesRemove(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        manager := rules.NewManager(getConfigDir())
        if err := manager.LoadRules(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load rules: %w", err)
        }</span>

        <span class="cov0" title="0">ruleName := args[0]
        if err := manager.RemoveRule(ruleName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove rule: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Rule '%s' removed successfully.\n", ruleName)
        return nil</span>
}

// runRulesEnable enables a rule
func runRulesEnable(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        manager := rules.NewManager(getConfigDir())
        if err := manager.LoadRules(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load rules: %w", err)
        }</span>

        <span class="cov0" title="0">ruleName := args[0]
        if err := manager.EnableRule(ruleName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to enable rule: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Rule '%s' enabled successfully.\n", ruleName)
        return nil</span>
}

// runRulesDisable disables a rule
func runRulesDisable(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        manager := rules.NewManager(getConfigDir())
        if err := manager.LoadRules(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load rules: %w", err)
        }</span>

        <span class="cov0" title="0">ruleName := args[0]
        if err := manager.DisableRule(ruleName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to disable rule: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Rule '%s' disabled successfully.\n", ruleName)
        return nil</span>
}

// runRulesInit initializes with example rules
func runRulesInit(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        manager := rules.NewManager(getConfigDir())
        if err := manager.LoadRules(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load rules: %w", err)
        }</span>

        <span class="cov0" title="0">if err := manager.CreateExampleRules(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create example rules: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Example rules created successfully in %s\n", manager.GetConfigPath())
        fmt.Println("Use 'fman rules list' to see the created rules.")
        fmt.Println("Rules are disabled by default for safety. Use 'fman rules enable &lt;name&gt;' to enable them.")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package cmd

import (
        "context"
        "fmt"
        "time"

        "github.com/devlikebear/fman/internal/daemon"
        "github.com/devlikebear/fman/internal/db"
        "github.com/devlikebear/fman/internal/scanner"
        "github.com/devlikebear/fman/internal/utils"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"
)

// scanCmd represents the scan command
var scanCmd = &amp;cobra.Command{
        Use:   "scan &lt;directory&gt;",
        Short: "Scans a directory and indexes file metadata into the database.",
        Long: `Recursively scans the specified directory, calculates metadata and a content hash
for each file, and stores this information in the fman database. This index is later
used by other commands like 'find' and 'organize'.

The scanner automatically skips system directories and handles permission errors gracefully.

Use --async flag to run the scan in the background using the daemon.`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // Check if async flag is set
                async, _ := cmd.Flags().GetBool("async")
                if async </span><span class="cov0" title="0">{
                        return runScanAsync(cmd, args)
                }</span>

                // Synchronous scan (existing behavior)
                <span class="cov0" title="0">forceSudo, _ := cmd.Flags().GetBool("force-sudo")

                // If force-sudo is requested and we're not already running as root
                if forceSudo &amp;&amp; !utils.IsRunningAsRoot() </span><span class="cov0" title="0">{
                        return utils.RunWithSudo(cmd, args)
                }</span>

                // Create a new Database instance for each command execution
                // This ensures that each command gets its own DB connection.
                <span class="cov0" title="0">dbInstance := db.NewDatabase(nil)
                return runScan(cmd, args, fileSystem, dbInstance)</span>
        },
}

func runScanAsync(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Get flags
        verbose, _ := cmd.Flags().GetBool("verbose")
        forceSudo, _ := cmd.Flags().GetBool("force-sudo")

        // Create scan options with resource optimization
        options := &amp;scanner.ScanOptions{
                Verbose:       verbose,
                ForceSudo:     forceSudo,
                ThrottleDelay: time.Millisecond * 10, // ÌååÏùº 100Í∞úÎßàÎã§ 10ms ÏßÄÏó∞
                MaxFileSize:   50 * 1024 * 1024,      // 50MB Ïù¥ÏÉÅ ÌååÏùºÏùÄ Ìï¥Ïãú Í±¥ÎÑàÎõ∞Í∏∞
        }

        // Create daemon client with faster timeouts for better responsiveness
        client := daemon.NewDaemonClient(nil)
        client.SetTimeout(2 * time.Second) // Îπ†Î•∏ ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï
        client.SetRetryCount(1)            // Ïû¨ÏãúÎèÑ ÌöüÏàò ÏµúÏÜåÌôî

        // Connect to daemon (will start daemon if not running)
        err := client.Connect()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to connect to daemon: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Disconnect()

        // Create scan request
        scanRequest := &amp;daemon.ScanRequest{
                Path:    args[0],
                Options: options,
        }

        // Enqueue scan job
        job, err := client.EnqueueScan(scanRequest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to enqueue scan job: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("üìã Scan job queued successfully\n")
        fmt.Printf("üÜî Job ID: %s\n", job.ID)
        fmt.Printf("üìÅ Path: %s\n", job.Path)
        fmt.Printf("‚è∞ Created: %s\n", job.CreatedAt.Format("2006-01-02 15:04:05"))
        fmt.Printf("üìä Status: %s\n", job.Status)

        fmt.Printf("\nüí° Use 'fman queue status %s' to check progress\n", job.ID)
        fmt.Printf("üí° Use 'fman queue list' to see all jobs\n")

        return nil</span>
}

func runScan(cmd *cobra.Command, args []string, fs afero.Fs, database db.DBInterface) error <span class="cov8" title="1">{
        // Get flags
        verbose, _ := cmd.Flags().GetBool("verbose")
        forceSudo, _ := cmd.Flags().GetBool("force-sudo")

        // Create scanner options with resource optimization
        options := &amp;scanner.ScanOptions{
                Verbose:       verbose,
                ForceSudo:     forceSudo,
                ThrottleDelay: time.Millisecond * 10, // ÌååÏùº 100Í∞úÎßàÎã§ 10ms ÏßÄÏó∞
                MaxFileSize:   50 * 1024 * 1024,      // 50MB Ïù¥ÏÉÅ ÌååÏùºÏùÄ Ìï¥Ïãú Í±¥ÎÑàÎõ∞Í∏∞
        }

        // Create scanner instance
        fileScanner := scanner.NewFileScanner(fs, database)

        // Create context for cancellation support
        ctx := context.Background()

        // Perform the scan
        stats, err := fileScanner.ScanDirectory(ctx, args[0], options)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Print scan statistics
        <span class="cov8" title="1">fmt.Println("\nüìä Scan Statistics:")
        fmt.Printf("‚úÖ Files indexed: %d\n", stats.FilesIndexed)
        fmt.Printf("‚è≠Ô∏è  Directories skipped: %d\n", stats.DirectoriesSkipped)
        fmt.Printf("‚ö†Ô∏è  Permission errors: %d\n", stats.PermissionErrors)

        if len(stats.SkippedPaths) &gt; 0 &amp;&amp; verbose </span><span class="cov0" title="0">{
                fmt.Println("\nüìã Skipped paths:")
                for _, path := range stats.SkippedPaths </span><span class="cov0" title="0">{
                        fmt.Printf("  - %s\n", path)
                }</span>
        }

        <span class="cov8" title="1">if stats.PermissionErrors &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nüí° Tip: %d paths were skipped due to permission errors.\n", stats.PermissionErrors)
                if !forceSudo &amp;&amp; !utils.IsRunningAsRoot() </span><span class="cov0" title="0">{
                        fmt.Println("   Use --force-sudo flag if you need to scan protected directories (use with caution).")
                }</span>
        }

        <span class="cov8" title="1">fmt.Println("‚úÖ Scan complete.")
        return nil</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(scanCmd)

        // Add flags for advanced options
        scanCmd.Flags().Bool("force-sudo", false, "Force scanning with elevated privileges (use with caution)")
        scanCmd.Flags().BoolP("verbose", "v", false, "Enable verbose output showing skipped paths")
        scanCmd.Flags().Bool("async", false, "Run scan in background using daemon")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package ai

import (
        "context"
        "fmt"

        "github.com/google/generative-ai-go/genai"
        "github.com/spf13/viper"
        "google.golang.org/api/option"
)

// GeminiProvider implements the AIProvider interface for Gemini.
type GeminiProvider struct {
        generativeModel GenerativeModelInterface // Field to hold the generative model, can be mocked for testing
}

// NewGeminiProvider creates a new GeminiProvider.
func NewGeminiProvider() AIProvider <span class="cov8" title="1">{
        return &amp;GeminiProvider{}
}</span>

var NewGenaiClient = genai.NewClient

// SetGenerativeModel allows injecting a mock GenerativeModel for testing.
func (p *GeminiProvider) SetGenerativeModel(model GenerativeModelInterface) <span class="cov8" title="1">{
        p.generativeModel = model
}</span>

// SuggestOrganization sends a request to the Gemini API to get organization suggestions.
func (p *GeminiProvider) SuggestOrganization(ctx context.Context, filePaths []string) (string, error) <span class="cov8" title="1">{
        apiKey := viper.GetString("gemini.api_key")
        if apiKey == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("gemini api_key is not set in the configuration")
        }</span>
        <span class="cov8" title="1">modelName := viper.GetString("gemini.model")
        if modelName == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("gemini model is not set in the configuration")
        }</span>

        <span class="cov8" title="1">var model GenerativeModelInterface
        if p.generativeModel != nil </span><span class="cov8" title="1">{ // Use injected model for testing
                model = p.generativeModel
        }</span> else<span class="cov0" title="0"> {
                client, err := NewGenaiClient(ctx, option.WithAPIKey(apiKey))
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to create gemini client: %w", err)
                }</span>
                <span class="cov0" title="0">defer client.Close()
                model = client.GenerativeModel(modelName)</span>
        }

        <span class="cov8" title="1">prompt := buildPrompt(filePaths)

        resp, err := model.GenerateContent(ctx, genai.Text(prompt))
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to generate content: %w", err)
        }</span>

        <span class="cov8" title="1">if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("received an empty response from Gemini")
        }</span>

        // Assuming the first part of the first candidate is the text we want.
        <span class="cov8" title="1">part := resp.Candidates[0].Content.Parts[0]
        if txt, ok := part.(genai.Text); ok </span><span class="cov8" title="1">{
                return string(txt), nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("unexpected response format from Gemini")</span>
}

func (p *GeminiProvider) String() string <span class="cov8" title="1">{
        return "gemini"
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package ai

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/spf13/viper"
)

// OllamaProvider implements the AIProvider interface for Ollama.
type OllamaProvider struct{}

// NewOllamaProvider creates a new OllamaProvider.
func NewOllamaProvider() AIProvider <span class="cov8" title="1">{
        return &amp;OllamaProvider{}
}</span>

type ollamaRequest struct {
        Model  string `json:"model"`
        Prompt string `json:"prompt"`
        Stream bool   `json:"stream"`
}

type ollamaResponse struct {
        Response string `json:"response"`
}

// SuggestOrganization sends a request to the Ollama API to get organization suggestions.
func (p *OllamaProvider) SuggestOrganization(ctx context.Context, filePaths []string) (string, error) <span class="cov8" title="1">{
        baseURL := viper.GetString("ollama.base_url")
        if baseURL == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("ollama base_url is not set in the configuration")
        }</span>
        <span class="cov8" title="1">model := viper.GetString("ollama.model")
        if model == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("ollama model is not set in the configuration")
        }</span>

        <span class="cov8" title="1">prompt := buildPrompt(filePaths)

        apiURL := fmt.Sprintf("%s/api/generate", baseURL)

        reqBody := ollamaRequest{
                Model:  model,
                Prompt: prompt,
                Stream: false,
        }

        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request body: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "POST", apiURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request to ollama: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return "", fmt.Errorf("received non-OK response from ollama: %s", resp.Status)
        }</span>

        <span class="cov8" title="1">var ollamaResp ollamaResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;ollamaResp); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to decode ollama response: %w", err)
        }</span>

        <span class="cov8" title="1">return ollamaResp.Response, nil</span>
}

func buildPrompt(filePaths []string) string <span class="cov8" title="1">{
        prompt := "You are a file organization expert. Based on the following file list, suggest a series of shell commands (like mv or mkdir) to organize them into a more structured directory. Only output the shell commands, without any explanation.\n\nFile list:\n"
        for _, path := range filePaths </span><span class="cov8" title="1">{
                prompt += fmt.Sprintf("- %s\n", path)
        }</span>
        <span class="cov8" title="1">return prompt</span>
}

func (p *OllamaProvider) String() string <span class="cov8" title="1">{
        return "ollama"
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package daemon

import (
        "encoding/json"
        "fmt"
        "net"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "syscall"
        "time"

        "github.com/google/uuid"
)

// DaemonClient implements ClientInterface for communicating with daemon
type DaemonClient struct {
        config     *DaemonConfig
        conn       net.Conn
        connected  bool
        timeout    time.Duration
        retryCount int
}

// NewDaemonClient creates a new daemon client
func NewDaemonClient(config *DaemonConfig) *DaemonClient <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = GetDefaultConfig()
        }</span>

        <span class="cov8" title="1">return &amp;DaemonClient{
                config:     config,
                timeout:    5 * time.Second, // Í∏∞Î≥∏ ÌÉÄÏûÑÏïÑÏõÉÏùÑ 5Ï¥àÎ°ú Îã®Ï∂ï
                retryCount: 2,               // Ïû¨ÏãúÎèÑ ÌöüÏàò Í∞êÏÜå
        }</span>
}

// SetTimeout sets the connection timeout
func (c *DaemonClient) SetTimeout(timeout time.Duration) <span class="cov8" title="1">{
        c.timeout = timeout
}</span>

// SetRetryCount sets the number of connection retries
func (c *DaemonClient) SetRetryCount(count int) <span class="cov8" title="1">{
        c.retryCount = count
}</span>

// Connect connects to the daemon
func (c *DaemonClient) Connect() error <span class="cov8" title="1">{
        if c.connected &amp;&amp; c.conn != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">socketPath := c.getSocketPath()

        // Try to connect with retries
        var lastErr error
        for i := 0; i &lt;= c.retryCount; i++ </span><span class="cov8" title="1">{
                conn, err := net.DialTimeout("unix", socketPath, c.timeout)
                if err == nil </span><span class="cov8" title="1">{
                        c.conn = conn
                        c.connected = true
                        return nil
                }</span>
                <span class="cov8" title="1">lastErr = err

                // If first attempt fails, try to start daemon
                if i == 0 &amp;&amp; !c.IsDaemonRunning() </span><span class="cov0" title="0">{
                        // Îç∞Î™¨ ÏãúÏûëÏùÑ ÏãúÎèÑÌïòÎêò, Îπ†Î•∏ Ïã§Ìå®Î•º ÏúÑÌï¥ Îçî ÏßßÏùÄ ÌÉÄÏûÑÏïÑÏõÉ ÏÇ¨Ïö©
                        startErr := c.startDaemonWithTimeout(1 * time.Second)
                        if startErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to start daemon: %w", startErr)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">if i &lt; c.retryCount </span><span class="cov0" title="0">{
                        // Îçî ÏßßÏùÄ ÎåÄÍ∏∞ ÏãúÍ∞ÑÏúºÎ°ú CPU ÏÇ¨Ïö©Îüâ Í∞êÏÜå
                        time.Sleep(time.Duration(500) * time.Millisecond)
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("failed to connect after %d retries: %w", c.retryCount, lastErr)</span>
}

// Disconnect disconnects from the daemon
func (c *DaemonClient) Disconnect() error <span class="cov8" title="1">{
        if c.conn != nil </span><span class="cov8" title="1">{
                err := c.conn.Close()
                c.conn = nil
                c.connected = false
                return err
        }</span>
        <span class="cov8" title="1">c.connected = false
        return nil</span>
}

// IsConnected checks if connected to daemon
func (c *DaemonClient) IsConnected() bool <span class="cov8" title="1">{
        return c.connected &amp;&amp; c.conn != nil
}</span>

// SendRequest sends a request and waits for response
func (c *DaemonClient) SendRequest(req *Request) (*Response, error) <span class="cov8" title="1">{
        if !c.IsConnected() </span><span class="cov8" title="1">{
                if err := c.Connect(); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to connect: %w", err)
                }</span>
        }

        // Create message with unique ID
        <span class="cov8" title="1">msg := &amp;Message{
                Type:      MessageTypeRequest,
                ID:        uuid.New().String(),
                Timestamp: time.Now(),
                Request:   req,
        }

        // Send request
        if err := c.sendMessage(msg); err != nil </span><span class="cov0" title="0">{
                c.Disconnect() // Reset connection on error
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>

        // Receive response
        <span class="cov8" title="1">respMsg, err := c.receiveMessage()
        if err != nil </span><span class="cov8" title="1">{
                c.Disconnect() // Reset connection on error
                return nil, fmt.Errorf("failed to receive response: %w", err)
        }</span>

        // Validate response
        <span class="cov8" title="1">if respMsg.Type != MessageTypeResponse </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected message type: %s", respMsg.Type)
        }</span>

        <span class="cov8" title="1">if respMsg.ID != msg.ID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("response ID mismatch: expected %s, got %s", msg.ID, respMsg.ID)
        }</span>

        <span class="cov8" title="1">if respMsg.Response == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing response data")
        }</span>

        <span class="cov8" title="1">return respMsg.Response, nil</span>
}

// IsDaemonRunning checks if daemon is running
func (c *DaemonClient) IsDaemonRunning() bool <span class="cov8" title="1">{
        pidPath := c.getPIDPath()

        // Check if PID file exists
        pidData, err := os.ReadFile(pidPath)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Parse PID
        <span class="cov8" title="1">pid, err := strconv.Atoi(string(pidData))
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if process exists
        <span class="cov8" title="1">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Send signal 0 to check if process is alive
        <span class="cov8" title="1">err = process.Signal(syscall.Signal(0))
        return err == nil</span>
}

// StartDaemon starts the daemon in background
func (c *DaemonClient) StartDaemon() error <span class="cov8" title="1">{
        if c.IsDaemonRunning() </span><span class="cov8" title="1">{
                return ErrDaemonAlreadyRunning
        }</span>

        // Get current executable path
        <span class="cov0" title="0">executable, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get executable path: %w", err)
        }</span>

        // Create daemon start command
        <span class="cov0" title="0">cmd := exec.Command(executable, "daemon", "start", "--background")

        // Set process attributes for background execution
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setsid: true, // Create new session
        }

        // Redirect stdout/stderr to prevent hanging
        cmd.Stdout = nil
        cmd.Stderr = nil
        cmd.Stdin = nil

        // Start daemon process
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start daemon process: %w", err)
        }</span>

        // Wait for daemon to be ready (Îçî ÏßßÏùÄ ÌÉÄÏûÑÏïÑÏõÉ)
        <span class="cov0" title="0">return c.waitForDaemon(3 * time.Second)</span>
}

// startDaemonWithTimeout starts daemon with custom timeout
func (c *DaemonClient) startDaemonWithTimeout(timeout time.Duration) error <span class="cov0" title="0">{
        if c.IsDaemonRunning() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get daemon executable path
        <span class="cov0" title="0">execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get executable path: %w", err)
        }</span>

        // Start daemon process with timeout context
        <span class="cov0" title="0">cmd := exec.Command(execPath, "daemon", "start")
        cmd.Stdout = nil
        cmd.Stderr = nil
        cmd.Stdin = nil

        // Start daemon process
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start daemon process: %w", err)
        }</span>

        // Wait for daemon to be ready with custom timeout
        <span class="cov0" title="0">return c.waitForDaemon(timeout)</span>
}

// StopDaemon stops the daemon
func (c *DaemonClient) StopDaemon() error <span class="cov8" title="1">{
        req := &amp;Request{
                Type: RequestTypeShutdown,
        }

        resp, err := c.SendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to send shutdown request: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("shutdown request failed: %s", resp.Error)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetStatus gets daemon status
func (c *DaemonClient) GetStatus() (*DaemonStatus, error) <span class="cov8" title="1">{
        req := &amp;Request{
                Type: RequestTypeStatus,
        }

        resp, err := c.SendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get status: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("status request failed: %s", resp.Error)
        }</span>

        // Parse response data
        <span class="cov0" title="0">statusData, ok := resp.Data.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid status response format")
        }</span>

        // Convert to DaemonStatus
        <span class="cov0" title="0">statusJSON, err := json.Marshal(statusData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal status data: %w", err)
        }</span>

        <span class="cov0" title="0">var status DaemonStatus
        if err := json.Unmarshal(statusJSON, &amp;status); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal status: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;status, nil</span>
}

// EnqueueScan adds a scan job to the queue
func (c *DaemonClient) EnqueueScan(request *ScanRequest) (*Job, error) <span class="cov8" title="1">{
        req := &amp;Request{
                Type: RequestTypeScan,
                Data: request,
        }

        resp, err := c.SendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to enqueue scan: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scan request failed: %s", resp.Error)
        }</span>

        // Parse response data
        <span class="cov0" title="0">jobData, ok := resp.Data.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid job response format")
        }</span>

        // Convert to Job
        <span class="cov0" title="0">jobJSON, err := json.Marshal(jobData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal job data: %w", err)
        }</span>

        <span class="cov0" title="0">var job Job
        if err := json.Unmarshal(jobJSON, &amp;job); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal job: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;job, nil</span>
}

// GetJob retrieves a job by ID
func (c *DaemonClient) GetJob(jobID string) (*Job, error) <span class="cov8" title="1">{
        req := &amp;Request{
                Type: RequestTypeJobStatus,
                Data: jobID,
        }

        resp, err := c.SendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get job: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("job request failed: %s", resp.Error)
        }</span>

        // Parse response data
        <span class="cov0" title="0">jobData, ok := resp.Data.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid job response format")
        }</span>

        // Convert to Job
        <span class="cov0" title="0">jobJSON, err := json.Marshal(jobData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal job data: %w", err)
        }</span>

        <span class="cov0" title="0">var job Job
        if err := json.Unmarshal(jobJSON, &amp;job); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal job: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;job, nil</span>
}

// CancelJob cancels a job
func (c *DaemonClient) CancelJob(jobID string) error <span class="cov8" title="1">{
        req := &amp;Request{
                Type: RequestTypeJobCancel,
                Data: jobID,
        }

        resp, err := c.SendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to cancel job: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("cancel request failed: %s", resp.Error)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListJobs returns all jobs with optional status filter
func (c *DaemonClient) ListJobs(status JobStatus) ([]*Job, error) <span class="cov8" title="1">{
        req := &amp;Request{
                Type: RequestTypeJobList,
                Data: string(status),
        }

        resp, err := c.SendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to list jobs: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list request failed: %s", resp.Error)
        }</span>

        // Parse response data
        <span class="cov0" title="0">jobsData, ok := resp.Data.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid jobs response format")
        }</span>

        // Convert to []*Job
        <span class="cov0" title="0">jobsJSON, err := json.Marshal(jobsData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal jobs data: %w", err)
        }</span>

        <span class="cov0" title="0">var jobs []*Job
        if err := json.Unmarshal(jobsJSON, &amp;jobs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal jobs: %w", err)
        }</span>

        <span class="cov0" title="0">return jobs, nil</span>
}

// ClearQueue clears all pending jobs
func (c *DaemonClient) ClearQueue() error <span class="cov8" title="1">{
        req := &amp;Request{
                Type: RequestTypeQueueClear,
        }

        resp, err := c.SendRequest(req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to clear queue: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("clear request failed: %s", resp.Error)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// sendMessage sends a message over the connection
func (c *DaemonClient) sendMessage(msg *Message) error <span class="cov8" title="1">{
        if c.conn == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("not connected")
        }</span>

        // Set write deadline
        <span class="cov8" title="1">if err := c.conn.SetWriteDeadline(time.Now().Add(c.timeout)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set write deadline: %w", err)
        }</span>

        // Encode message as JSON
        <span class="cov8" title="1">data, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        // Send message length first (4 bytes)
        <span class="cov8" title="1">length := uint32(len(data))
        lengthBytes := []byte{
                byte(length &gt;&gt; 24),
                byte(length &gt;&gt; 16),
                byte(length &gt;&gt; 8),
                byte(length),
        }

        if _, err := c.conn.Write(lengthBytes); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write message length: %w", err)
        }</span>

        // Send message data
        <span class="cov8" title="1">if _, err := c.conn.Write(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write message data: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// receiveMessage receives a message from the connection
func (c *DaemonClient) receiveMessage() (*Message, error) <span class="cov8" title="1">{
        if c.conn == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("not connected")
        }</span>

        // Set read deadline
        <span class="cov8" title="1">if err := c.conn.SetReadDeadline(time.Now().Add(c.timeout)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set read deadline: %w", err)
        }</span>

        // Read message length (4 bytes)
        <span class="cov8" title="1">lengthBytes := make([]byte, 4)
        if _, err := c.conn.Read(lengthBytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read message length: %w", err)
        }</span>

        // Parse length
        <span class="cov8" title="1">length := uint32(lengthBytes[0])&lt;&lt;24 | uint32(lengthBytes[1])&lt;&lt;16 | uint32(lengthBytes[2])&lt;&lt;8 | uint32(lengthBytes[3])
        if length &gt; 1024*1024 </span><span class="cov8" title="1">{ // 1MB limit
                return nil, fmt.Errorf("message too large: %d bytes", length)
        }</span>

        // Read message data
        <span class="cov8" title="1">data := make([]byte, length)
        if _, err := c.conn.Read(data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read message data: %w", err)
        }</span>

        // Decode JSON
        <span class="cov8" title="1">var msg Message
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal message: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;msg, nil</span>
}

// waitForDaemon waits for daemon to be ready
func (c *DaemonClient) waitForDaemon(timeout time.Duration) error <span class="cov8" title="1">{
        deadline := time.Now().Add(timeout)

        // Ï≤òÏùåÏóêÎäî Îçî ÏûêÏ£º ÌôïÏù∏ÌïòÍ≥†, Ï†êÏßÑÏ†ÅÏúºÎ°ú Í∞ÑÍ≤©ÏùÑ ÎäòÎ†§ÏÑú CPU ÏÇ¨Ïö©Îüâ Í∞êÏÜå
        checkInterval := 100 * time.Millisecond
        maxInterval := 1 * time.Second

        for time.Now().Before(deadline) </span><span class="cov8" title="1">{
                if c.IsDaemonRunning() </span><span class="cov0" title="0">{
                        // Try to connect to verify daemon is ready (Ïû¨Í∑Ä Ìò∏Ï∂ú Î∞©ÏßÄ)
                        socketPath := c.getSocketPath()
                        conn, err := net.DialTimeout("unix", socketPath, c.timeout)
                        if err == nil </span><span class="cov0" title="0">{
                                conn.Close() // Close test connection immediately
                                return nil
                        }</span>
                }

                // Ï†êÏßÑÏ†ÅÏúºÎ°ú ÎåÄÍ∏∞ ÏãúÍ∞Ñ Ï¶ùÍ∞ÄÌïòÏó¨ CPU Î∂ÄÌïò Í∞êÏÜå
                <span class="cov8" title="1">time.Sleep(checkInterval)
                if checkInterval &lt; maxInterval </span><span class="cov8" title="1">{
                        checkInterval = checkInterval * 2
                        if checkInterval &gt; maxInterval </span><span class="cov0" title="0">{
                                checkInterval = maxInterval
                        }</span>
                }
        }

        <span class="cov8" title="1">return fmt.Errorf("daemon did not start within %v", timeout)</span>
}

// getSocketPath returns the socket file path
func (c *DaemonClient) getSocketPath() string <span class="cov8" title="1">{
        if filepath.IsAbs(c.config.SocketPath) </span><span class="cov8" title="1">{
                return c.config.SocketPath
        }</span>

        <span class="cov8" title="1">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return c.config.SocketPath
        }</span>

        <span class="cov8" title="1">return filepath.Join(homeDir, ".fman", c.config.SocketPath)</span>
}

// getPIDPath returns the PID file path
func (c *DaemonClient) getPIDPath() string <span class="cov8" title="1">{
        if filepath.IsAbs(c.config.PIDPath) </span><span class="cov8" title="1">{
                return c.config.PIDPath
        }</span>

        <span class="cov8" title="1">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return c.config.PIDPath
        }</span>

        <span class="cov8" title="1">return filepath.Join(homeDir, ".fman", c.config.PIDPath)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package daemon

import (
        "fmt"
        "path/filepath"
        "runtime"
        "strings"
        "sync"
)

// PathChecker provides path normalization and conflict detection functionality
type PathChecker struct {
        // Cache for normalized paths to improve performance
        normalizedCache map[string]string
        cacheMu         sync.RWMutex
}

// NewPathChecker creates a new PathChecker instance
func NewPathChecker() *PathChecker <span class="cov8" title="1">{
        return &amp;PathChecker{
                normalizedCache: make(map[string]string),
        }
}</span>

// NormalizePath normalizes a path by cleaning it and resolving symbolic links
func (pc *PathChecker) NormalizePath(path string) (string, error) <span class="cov8" title="1">{
        // Check cache first
        pc.cacheMu.RLock()
        if normalized, exists := pc.normalizedCache[path]; exists </span><span class="cov8" title="1">{
                pc.cacheMu.RUnlock()
                return normalized, nil
        }</span>
        <span class="cov8" title="1">pc.cacheMu.RUnlock()

        // Clean the path first
        cleaned := filepath.Clean(path)

        // Convert to absolute path
        abs, err := filepath.Abs(cleaned)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get absolute path for %s: %w", path, err)
        }</span>

        // Resolve symbolic links
        <span class="cov8" title="1">resolved, err := filepath.EvalSymlinks(abs)
        if err != nil </span><span class="cov8" title="1">{
                // If symlink resolution fails, use the absolute path
                // This can happen if the path doesn't exist yet or permission denied
                resolved = abs
        }</span>

        // For consistency, try to resolve symlinks for the parent directory
        // if the full path resolution failed
        <span class="cov8" title="1">if resolved == abs &amp;&amp; err != nil </span><span class="cov8" title="1">{
                dir := filepath.Dir(abs)
                resolvedDir, dirErr := filepath.EvalSymlinks(dir)
                if dirErr == nil </span><span class="cov8" title="1">{
                        resolved = filepath.Join(resolvedDir, filepath.Base(abs))
                }</span>
        }

        // Normalize path separators and case (for case-insensitive filesystems)
        <span class="cov8" title="1">normalized := pc.normalizePlatformSpecific(resolved)

        // Cache the result
        pc.cacheMu.Lock()
        pc.normalizedCache[path] = normalized
        pc.cacheMu.Unlock()

        return normalized, nil</span>
}

// normalizePlatformSpecific handles platform-specific path normalization
func (pc *PathChecker) normalizePlatformSpecific(path string) string <span class="cov8" title="1">{
        // Convert to forward slashes for consistency
        normalized := filepath.ToSlash(path)

        // On Windows and macOS (case-insensitive filesystems), convert to lowercase
        if runtime.GOOS == "windows" || runtime.GOOS == "darwin" </span><span class="cov8" title="1">{
                normalized = strings.ToLower(normalized)
        }</span>

        // Ensure trailing slash is removed for consistency
        <span class="cov8" title="1">if len(normalized) &gt; 1 &amp;&amp; strings.HasSuffix(normalized, "/") </span><span class="cov0" title="0">{
                normalized = strings.TrimSuffix(normalized, "/")
        }</span>

        <span class="cov8" title="1">return normalized</span>
}

// IsParentPath checks if parentPath is a parent directory of childPath
func (pc *PathChecker) IsParentPath(parentPath, childPath string) (bool, error) <span class="cov8" title="1">{
        normalizedParent, err := pc.NormalizePath(parentPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to normalize parent path %s: %w", parentPath, err)
        }</span>

        <span class="cov8" title="1">normalizedChild, err := pc.NormalizePath(childPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to normalize child path %s: %w", childPath, err)
        }</span>

        // Check if child path starts with parent path
        <span class="cov8" title="1">if normalizedParent == normalizedChild </span><span class="cov8" title="1">{
                return false, nil // Same path, not parent-child relationship
        }</span>

        // Ensure parent path ends with separator for accurate comparison
        <span class="cov8" title="1">parentWithSep := normalizedParent
        if !strings.HasSuffix(parentWithSep, "/") </span><span class="cov8" title="1">{
                parentWithSep += "/"
        }</span>

        <span class="cov8" title="1">return strings.HasPrefix(normalizedChild, parentWithSep), nil</span>
}

// HasConflict checks if a new path conflicts with existing job paths
func (pc *PathChecker) HasConflict(newPath string, existingPaths []string) (*PathConflict, error) <span class="cov8" title="1">{
        normalizedNew, err := pc.NormalizePath(newPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to normalize new path %s: %w", newPath, err)
        }</span>

        <span class="cov8" title="1">for _, existingPath := range existingPaths </span><span class="cov8" title="1">{
                normalizedExisting, err := pc.NormalizePath(existingPath)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip paths that can't be normalized
                        continue</span>
                }

                // Check if paths are identical
                <span class="cov8" title="1">if normalizedNew == normalizedExisting </span><span class="cov8" title="1">{
                        return &amp;PathConflict{
                                Type:         ConflictTypeDuplicate,
                                ExistingPath: existingPath,
                                ConflictPath: newPath,
                                Reason:       "identical paths",
                        }, nil
                }</span>

                // Check if new path is a parent of existing path
                <span class="cov8" title="1">isParent, err := pc.IsParentPath(newPath, existingPath)
                if err == nil &amp;&amp; isParent </span><span class="cov8" title="1">{
                        return &amp;PathConflict{
                                Type:         ConflictTypeParentChild,
                                ExistingPath: existingPath,
                                ConflictPath: newPath,
                                Reason:       "new path is parent of existing path",
                        }, nil
                }</span>

                // Check if existing path is a parent of new path
                <span class="cov8" title="1">isChild, err := pc.IsParentPath(existingPath, newPath)
                if err == nil &amp;&amp; isChild </span><span class="cov8" title="1">{
                        return &amp;PathConflict{
                                Type:         ConflictTypeChildParent,
                                ExistingPath: existingPath,
                                ConflictPath: newPath,
                                Reason:       "new path is child of existing path",
                        }, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, nil</span> // No conflict found
}

// OptimizePaths removes redundant paths from a list, keeping only the most efficient set
func (pc *PathChecker) OptimizePaths(paths []string) (*PathOptimizationResult, error) <span class="cov8" title="1">{
        if len(paths) == 0 </span><span class="cov8" title="1">{
                return &amp;PathOptimizationResult{
                        OptimizedPaths: []string{},
                        RemovedPaths:   []string{},
                        Conflicts:      []*PathConflict{},
                }, nil
        }</span>

        <span class="cov8" title="1">result := &amp;PathOptimizationResult{
                OptimizedPaths: []string{},
                RemovedPaths:   []string{},
                Conflicts:      []*PathConflict{},
        }

        // Normalize all paths first
        normalizedPaths := make(map[string]string) // normalized -&gt; original
        for _, path := range paths </span><span class="cov8" title="1">{
                normalized, err := pc.NormalizePath(path)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip paths that can't be normalized
                        result.RemovedPaths = append(result.RemovedPaths, path)
                        result.Conflicts = append(result.Conflicts, &amp;PathConflict{
                                Type:         ConflictTypeInvalid,
                                ExistingPath: "",
                                ConflictPath: path,
                                Reason:       fmt.Sprintf("normalization failed: %v", err),
                        })
                        continue</span>
                }

                // Check for exact duplicates
                <span class="cov8" title="1">if existingOriginal, exists := normalizedPaths[normalized]; exists </span><span class="cov8" title="1">{
                        result.RemovedPaths = append(result.RemovedPaths, path)
                        result.Conflicts = append(result.Conflicts, &amp;PathConflict{
                                Type:         ConflictTypeDuplicate,
                                ExistingPath: existingOriginal,
                                ConflictPath: path,
                                Reason:       "duplicate after normalization",
                        })
                        continue</span>
                }

                <span class="cov8" title="1">normalizedPaths[normalized] = path</span>
        }

        // Convert to slices for easier processing
        <span class="cov8" title="1">uniquePaths := make([]string, 0, len(normalizedPaths))
        for _, original := range normalizedPaths </span><span class="cov8" title="1">{
                uniquePaths = append(uniquePaths, original)
        }</span>

        // Build a map to track which paths should be kept
        <span class="cov8" title="1">shouldKeep := make(map[string]bool)
        for _, path := range uniquePaths </span><span class="cov8" title="1">{
                shouldKeep[path] = true
        }</span>

        // Find parent-child relationships and mark children for removal
        <span class="cov8" title="1">for i, path1 := range uniquePaths </span><span class="cov8" title="1">{
                if !shouldKeep[path1] </span><span class="cov8" title="1">{
                        continue</span> // Already marked for removal
                }

                <span class="cov8" title="1">for j, path2 := range uniquePaths </span><span class="cov8" title="1">{
                        if i == j || !shouldKeep[path2] </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">isParent, err := pc.IsParentPath(path1, path2)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if isParent </span><span class="cov8" title="1">{
                                // path1 is parent of path2, so remove path2
                                shouldKeep[path2] = false
                                result.RemovedPaths = append(result.RemovedPaths, path2)
                                result.Conflicts = append(result.Conflicts, &amp;PathConflict{
                                        Type:         ConflictTypeChildParent,
                                        ExistingPath: path1,
                                        ConflictPath: path2,
                                        Reason:       "child path removed in favor of parent",
                                })
                        }</span>
                }
        }

        // Add remaining paths that should be kept
        <span class="cov8" title="1">for _, path := range uniquePaths </span><span class="cov8" title="1">{
                if shouldKeep[path] </span><span class="cov8" title="1">{
                        result.OptimizedPaths = append(result.OptimizedPaths, path)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// ClearCache clears the normalized path cache
func (pc *PathChecker) ClearCache() <span class="cov8" title="1">{
        pc.cacheMu.Lock()
        defer pc.cacheMu.Unlock()
        pc.normalizedCache = make(map[string]string)
}</span>

// GetCacheSize returns the current cache size
func (pc *PathChecker) GetCacheSize() int <span class="cov8" title="1">{
        pc.cacheMu.RLock()
        defer pc.cacheMu.RUnlock()
        return len(pc.normalizedCache)
}</span>

// ConflictType represents the type of path conflict
type ConflictType string

const (
        // ConflictTypeDuplicate indicates identical paths
        ConflictTypeDuplicate ConflictType = "duplicate"
        // ConflictTypeParentChild indicates new path is parent of existing
        ConflictTypeParentChild ConflictType = "parent_child"
        // ConflictTypeChildParent indicates new path is child of existing
        ConflictTypeChildParent ConflictType = "child_parent"
        // ConflictTypeInvalid indicates invalid path
        ConflictTypeInvalid ConflictType = "invalid"
)

// PathConflict represents a conflict between paths
type PathConflict struct {
        Type         ConflictType `json:"type"`
        ExistingPath string       `json:"existing_path"`
        ConflictPath string       `json:"conflict_path"`
        Reason       string       `json:"reason"`
}

// PathOptimizationResult contains the result of path optimization
type PathOptimizationResult struct {
        OptimizedPaths []string        `json:"optimized_paths"`
        RemovedPaths   []string        `json:"removed_paths"`
        Conflicts      []*PathConflict `json:"conflicts"`
}

// String returns a string representation of the conflict
func (pc *PathConflict) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s conflict: %s (existing: %s, conflict: %s)",
                pc.Type, pc.Reason, pc.ExistingPath, pc.ConflictPath)
}</span>

// String returns a string representation of the optimization result
func (por *PathOptimizationResult) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Optimized: %d paths, Removed: %d paths, Conflicts: %d",
                len(por.OptimizedPaths), len(por.RemovedPaths), len(por.Conflicts))
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package daemon

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// JobQueue implements QueueInterface with in-memory storage
type JobQueue struct {
        // mutex for thread-safe operations
        mu sync.RWMutex

        // jobs stores all jobs by ID
        jobs map[string]*Job

        // pending queue for jobs waiting to be processed
        pending []*Job

        // running jobs currently being processed
        running map[string]*Job

        // completed jobs (for history)
        completed []*Job

        // failed jobs (for history)
        failed []*Job

        // cancelled jobs (for history)
        cancelled []*Job

        // configuration
        maxQueueSize int
        maxHistory   int

        // channels for blocking operations
        newJobCh chan struct{}

        // statistics
        stats struct {
                totalAdded     int
                totalCompleted int
                totalFailed    int
                totalCancelled int
        }
}

// NewJobQueue creates a new job queue with the specified configuration
func NewJobQueue(maxQueueSize, maxHistory int) *JobQueue <span class="cov8" title="1">{
        if maxQueueSize &lt;= 0 </span><span class="cov8" title="1">{
                maxQueueSize = DefaultQueueSize
        }</span>
        <span class="cov8" title="1">if maxHistory &lt;= 0 </span><span class="cov8" title="1">{
                maxHistory = 1000 // Default to keep 1000 completed jobs
        }</span>

        <span class="cov8" title="1">return &amp;JobQueue{
                jobs:         make(map[string]*Job),
                pending:      make([]*Job, 0),
                running:      make(map[string]*Job),
                completed:    make([]*Job, 0),
                failed:       make([]*Job, 0),
                cancelled:    make([]*Job, 0),
                maxQueueSize: maxQueueSize,
                maxHistory:   maxHistory,
                newJobCh:     make(chan struct{}, 1),
        }</span>
}

// Add adds a job to the queue
func (q *JobQueue) Add(job *Job) error <span class="cov8" title="1">{
        if job == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("job cannot be nil")
        }</span>

        <span class="cov8" title="1">q.mu.Lock()
        defer q.mu.Unlock()

        // Check if job already exists
        if _, exists := q.jobs[job.ID]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("job with ID %s already exists", job.ID)
        }</span>

        // Check queue size limit
        <span class="cov8" title="1">if len(q.pending) &gt;= q.maxQueueSize </span><span class="cov8" title="1">{
                return fmt.Errorf("queue is full (max size: %d)", q.maxQueueSize)
        }</span>

        // Check for duplicate paths in pending jobs
        <span class="cov8" title="1">for _, pendingJob := range q.pending </span><span class="cov8" title="1">{
                if pendingJob.Path == job.Path </span><span class="cov8" title="1">{
                        return fmt.Errorf("job for path %s is already pending", job.Path)
                }</span>
        }

        // Check for duplicate paths in running jobs
        <span class="cov8" title="1">for _, runningJob := range q.running </span><span class="cov8" title="1">{
                if runningJob.Path == job.Path </span><span class="cov8" title="1">{
                        return fmt.Errorf("job for path %s is already running", job.Path)
                }</span>
        }

        // Set job status and add to queue
        <span class="cov8" title="1">job.Status = JobStatusPending
        job.CreatedAt = time.Now()

        q.jobs[job.ID] = job
        q.pending = append(q.pending, job)
        q.stats.totalAdded++

        // Notify waiting workers
        select </span>{
        case q.newJobCh &lt;- struct{}{}:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1"></span>
                // Channel is full, that's ok
        }

        <span class="cov8" title="1">return nil</span>
}

// Next gets the next job from the queue (blocking)
func (q *JobQueue) Next(ctx context.Context) (*Job, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                q.mu.Lock()

                // Check if there are pending jobs
                if len(q.pending) &gt; 0 </span><span class="cov8" title="1">{
                        // Get the first job (FIFO)
                        job := q.pending[0]
                        q.pending = q.pending[1:]

                        // Move to running
                        job.Status = JobStatusRunning
                        now := time.Now()
                        job.StartedAt = &amp;now
                        q.running[job.ID] = job

                        q.mu.Unlock()
                        return job, nil
                }</span>

                <span class="cov8" title="1">q.mu.Unlock()

                // Wait for new jobs or context cancellation
                select </span>{
                case &lt;-q.newJobCh:<span class="cov0" title="0">
                        // Try again
                        continue</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil, ctx.Err()</span>
                }
        }
}

// Get retrieves a job by ID
func (q *JobQueue) Get(jobID string) (*Job, error) <span class="cov8" title="1">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        job, exists := q.jobs[jobID]
        if !exists </span><span class="cov8" title="1">{
                return nil, ErrJobNotFound
        }</span>

        // Return a copy to prevent external modification
        <span class="cov8" title="1">jobCopy := *job
        return &amp;jobCopy, nil</span>
}

// Update updates a job's status and data
func (q *JobQueue) Update(job *Job) error <span class="cov8" title="1">{
        if job == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("job cannot be nil")
        }</span>

        <span class="cov8" title="1">q.mu.Lock()
        defer q.mu.Unlock()

        existingJob, exists := q.jobs[job.ID]
        if !exists </span><span class="cov8" title="1">{
                return ErrJobNotFound
        }</span>

        // Update the job in place
        <span class="cov8" title="1">existingJob.Status = job.Status
        existingJob.Stats = job.Stats
        existingJob.Error = job.Error
        existingJob.Progress = job.Progress

        // Handle status transitions
        switch job.Status </span>{
        case JobStatusCompleted:<span class="cov8" title="1">
                if existingJob.CompletedAt == nil </span><span class="cov8" title="1">{
                        now := time.Now()
                        existingJob.CompletedAt = &amp;now
                }</span>

                // Move from running to completed
                <span class="cov8" title="1">delete(q.running, job.ID)
                q.completed = append(q.completed, existingJob)
                q.stats.totalCompleted++

                // Cleanup old completed jobs
                q.cleanupHistory(&amp;q.completed)</span>

        case JobStatusFailed:<span class="cov8" title="1">
                if existingJob.CompletedAt == nil </span><span class="cov8" title="1">{
                        now := time.Now()
                        existingJob.CompletedAt = &amp;now
                }</span>

                // Move from running to failed
                <span class="cov8" title="1">delete(q.running, job.ID)
                q.failed = append(q.failed, existingJob)
                q.stats.totalFailed++

                // Cleanup old failed jobs
                q.cleanupHistory(&amp;q.failed)</span>

        case JobStatusCancelled:<span class="cov8" title="1">
                if existingJob.CompletedAt == nil </span><span class="cov8" title="1">{
                        now := time.Now()
                        existingJob.CompletedAt = &amp;now
                }</span>

                // Remove from running or pending
                <span class="cov8" title="1">delete(q.running, job.ID)
                q.removeFromPending(job.ID)
                q.cancelled = append(q.cancelled, existingJob)
                q.stats.totalCancelled++

                // Cleanup old cancelled jobs
                q.cleanupHistory(&amp;q.cancelled)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// List returns jobs with optional status filter
func (q *JobQueue) List(status JobStatus) ([]*Job, error) <span class="cov8" title="1">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        var result []*Job

        switch status </span>{
        case JobStatusPending:<span class="cov8" title="1">
                result = make([]*Job, len(q.pending))
                for i, job := range q.pending </span><span class="cov8" title="1">{
                        jobCopy := *job
                        result[i] = &amp;jobCopy
                }</span>
        case JobStatusRunning:<span class="cov8" title="1">
                result = make([]*Job, 0, len(q.running))
                for _, job := range q.running </span><span class="cov8" title="1">{
                        jobCopy := *job
                        result = append(result, &amp;jobCopy)
                }</span>
        case JobStatusCompleted:<span class="cov8" title="1">
                result = make([]*Job, len(q.completed))
                for i, job := range q.completed </span><span class="cov8" title="1">{
                        jobCopy := *job
                        result[i] = &amp;jobCopy
                }</span>
        case JobStatusFailed:<span class="cov8" title="1">
                result = make([]*Job, len(q.failed))
                for i, job := range q.failed </span><span class="cov0" title="0">{
                        jobCopy := *job
                        result[i] = &amp;jobCopy
                }</span>
        case JobStatusCancelled:<span class="cov0" title="0">
                result = make([]*Job, len(q.cancelled))
                for i, job := range q.cancelled </span><span class="cov0" title="0">{
                        jobCopy := *job
                        result[i] = &amp;jobCopy
                }</span>
        default:<span class="cov8" title="1">
                // Return all jobs
                result = make([]*Job, 0, len(q.jobs))
                for _, job := range q.jobs </span><span class="cov8" title="1">{
                        jobCopy := *job
                        result = append(result, &amp;jobCopy)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// Cancel marks a job as cancelled
func (q *JobQueue) Cancel(jobID string) error <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()

        job, exists := q.jobs[jobID]
        if !exists </span><span class="cov8" title="1">{
                return ErrJobNotFound
        }</span>

        // Can only cancel pending or running jobs
        <span class="cov8" title="1">if job.Status != JobStatusPending &amp;&amp; job.Status != JobStatusRunning </span><span class="cov8" title="1">{
                return fmt.Errorf("job %s cannot be cancelled (status: %s)", jobID, job.Status)
        }</span>

        // Update job status
        <span class="cov8" title="1">job.Status = JobStatusCancelled
        now := time.Now()
        job.CompletedAt = &amp;now

        // Remove from pending or running
        q.removeFromPending(jobID)
        delete(q.running, jobID)

        // Add to cancelled
        q.cancelled = append(q.cancelled, job)
        q.stats.totalCancelled++

        // Cleanup old cancelled jobs
        q.cleanupHistory(&amp;q.cancelled)

        return nil</span>
}

// Clear removes all pending jobs
func (q *JobQueue) Clear() error <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()

        // Remove pending jobs from jobs map
        for _, job := range q.pending </span><span class="cov8" title="1">{
                delete(q.jobs, job.ID)
        }</span>

        // Clear pending queue
        <span class="cov8" title="1">q.pending = make([]*Job, 0)

        return nil</span>
}

// Size returns the current queue size
func (q *JobQueue) Size() int <span class="cov8" title="1">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        return len(q.pending)
}</span>

// Stats returns queue statistics
func (q *JobQueue) Stats() map[string]int <span class="cov8" title="1">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        return map[string]int{
                "pending":         len(q.pending),
                "running":         len(q.running),
                "completed":       len(q.completed),
                "failed":          len(q.failed),
                "cancelled":       len(q.cancelled),
                "total_added":     q.stats.totalAdded,
                "total_completed": q.stats.totalCompleted,
                "total_failed":    q.stats.totalFailed,
                "total_cancelled": q.stats.totalCancelled,
        }
}</span>

// Helper methods

// removeFromPending removes a job from the pending queue
func (q *JobQueue) removeFromPending(jobID string) <span class="cov8" title="1">{
        for i, job := range q.pending </span><span class="cov8" title="1">{
                if job.ID == jobID </span><span class="cov8" title="1">{
                        q.pending = append(q.pending[:i], q.pending[i+1:]...)
                        break</span>
                }
        }
}

// cleanupHistory removes old jobs from history to prevent memory leaks
func (q *JobQueue) cleanupHistory(history *[]*Job) <span class="cov8" title="1">{
        if len(*history) &gt; q.maxHistory </span><span class="cov8" title="1">{
                // Keep only the most recent jobs
                *history = (*history)[len(*history)-q.maxHistory:]
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package daemon

import (
        "context"
        "runtime"
        "sync"
        "time"
)

// ResourceLimits Îç∞Î™¨Ïùò Î¶¨ÏÜåÏä§ ÏÇ¨Ïö© Ï†úÌïú ÏÑ§Ï†ï
type ResourceLimits struct {
        MaxMemoryMB   uint64        // ÏµúÎåÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ (MB)
        MaxCPUPercent float64       // ÏµúÎåÄ CPU ÏÇ¨Ïö©Î•† (%)
        CheckInterval time.Duration // Î™®ÎãàÌÑ∞ÎßÅ Ï£ºÍ∏∞
        ThrottleDelay time.Duration // Ï†úÌïú Ïãú ÏßÄÏó∞ ÏãúÍ∞Ñ
}

// ResourceMonitor ÏãúÏä§ÌÖú Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ÎßÅ Î∞è Ï†úÏñ¥
type ResourceMonitor struct {
        limits        ResourceLimits
        isThrottling  bool
        lastCPUTime   time.Duration
        lastCheckTime time.Time
        mu            sync.RWMutex
        ctx           context.Context
        cancel        context.CancelFunc
}

// ResourceStatus ÌòÑÏû¨ Î¶¨ÏÜåÏä§ ÏÇ¨Ïö© ÏÉÅÌÉú
type ResourceStatus struct {
        MemoryUsageMB float64
        CPUPercent    float64
        IsThrottling  bool
        LastChecked   time.Time
}

// NewResourceMonitor ÏÉàÎ°úÏö¥ Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ ÏÉùÏÑ±
func NewResourceMonitor(limits ResourceLimits) *ResourceMonitor <span class="cov8" title="1">{
        if limits.MaxMemoryMB == 0 </span><span class="cov0" title="0">{
                limits.MaxMemoryMB = 500 // Í∏∞Î≥∏Í∞í: 500MB
        }</span>
        <span class="cov8" title="1">if limits.MaxCPUPercent == 0 </span><span class="cov0" title="0">{
                limits.MaxCPUPercent = 25.0 // Í∏∞Î≥∏Í∞í: 25%
        }</span>
        <span class="cov8" title="1">if limits.CheckInterval == 0 </span><span class="cov0" title="0">{
                limits.CheckInterval = 5 * time.Second // Í∏∞Î≥∏Í∞í: 5Ï¥à
        }</span>
        <span class="cov8" title="1">if limits.ThrottleDelay == 0 </span><span class="cov0" title="0">{
                limits.ThrottleDelay = 100 * time.Millisecond // Í∏∞Î≥∏Í∞í: 100ms
        }</span>

        <span class="cov8" title="1">return &amp;ResourceMonitor{
                limits:        limits,
                lastCheckTime: time.Now(),
        }</span>
}

// Start Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
func (rm *ResourceMonitor) Start(ctx context.Context) <span class="cov8" title="1">{
        rm.mu.Lock()
        rm.ctx, rm.cancel = context.WithCancel(ctx)
        rm.mu.Unlock()

        go rm.monitorLoop()
}</span>

// Stop Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
func (rm *ResourceMonitor) Stop() <span class="cov8" title="1">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        if rm.cancel != nil </span><span class="cov8" title="1">{
                rm.cancel()
        }</span>
}

// GetStatus ÌòÑÏû¨ Î¶¨ÏÜåÏä§ ÏÉÅÌÉú Î∞òÌôò
func (rm *ResourceMonitor) GetStatus() ResourceStatus <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        memoryMB := float64(m.Alloc) / 1024 / 1024

        return ResourceStatus{
                MemoryUsageMB: memoryMB,
                CPUPercent:    rm.getCurrentCPUUsage(),
                IsThrottling:  rm.isThrottling,
                LastChecked:   rm.lastCheckTime,
        }
}</span>

// ShouldThrottle ÌòÑÏû¨ Ïì∞Î°úÌãÄÎßÅÏù¥ ÌïÑÏöîÌïúÏßÄ ÌôïÏù∏
func (rm *ResourceMonitor) ShouldThrottle() bool <span class="cov8" title="1">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()
        return rm.isThrottling
}</span>

// WaitIfThrottling Ïì∞Î°úÌãÄÎßÅ Ï§ëÏù¥Î©¥ ÎåÄÍ∏∞
func (rm *ResourceMonitor) WaitIfThrottling(ctx context.Context) error <span class="cov8" title="1">{
        if !rm.ShouldThrottle() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(rm.limits.ThrottleDelay):<span class="cov0" title="0">
                return nil</span>
        }
}

// ForceGC Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ Í∞ïÏ†ú Ïã§Ìñâ
func (rm *ResourceMonitor) ForceGC() <span class="cov0" title="0">{
        runtime.GC()
        runtime.GC() // Îëê Î≤à Ïã§ÌñâÌïòÏó¨ ÌôïÏã§Ìûà Ï†ïÎ¶¨
}</span>

// monitorLoop Î™®ÎãàÌÑ∞ÎßÅ Î©îÏù∏ Î£®ÌîÑ
func (rm *ResourceMonitor) monitorLoop() <span class="cov8" title="1">{
        ticker := time.NewTicker(rm.limits.CheckInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rm.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rm.checkAndUpdateStatus()</span>
                }
        }
}

// checkAndUpdateStatus Î¶¨ÏÜåÏä§ ÏÉÅÌÉú ÌôïÏù∏ Î∞è ÏóÖÎç∞Ïù¥Ìä∏
func (rm *ResourceMonitor) checkAndUpdateStatus() <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        memoryMB := float64(m.Alloc) / 1024 / 1024
        cpuPercent := rm.getCurrentCPUUsage()

        // Î©îÎ™®Î¶¨ ÎòêÎäî CPU ÏÇ¨Ïö©ÎüâÏù¥ Ï†úÌïúÏùÑ Ï¥àÍ≥ºÌïòÎäîÏßÄ ÌôïÏù∏
        memoryExceeded := memoryMB &gt; float64(rm.limits.MaxMemoryMB)
        cpuExceeded := cpuPercent &gt; rm.limits.MaxCPUPercent

        rm.isThrottling = memoryExceeded || cpuExceeded
        rm.lastCheckTime = time.Now()

        // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏúºÎ©¥ Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò Ïã§Ìñâ
        if memoryExceeded </span><span class="cov0" title="0">{
                runtime.GC()
        }</span>
}

// getCurrentCPUUsage ÌòÑÏû¨ CPU ÏÇ¨Ïö©Î•† Í≥ÑÏÇ∞ (Í∞ÑÎã®Ìïú Ï∂îÏ†ï)
func (rm *ResourceMonitor) getCurrentCPUUsage() float64 <span class="cov0" title="0">{
        // Í≥†Î£®Ìã¥ ÏàòÎ•º Í∏∞Î∞òÏúºÎ°ú Ìïú Í∞ÑÎã®Ìïú CPU ÏÇ¨Ïö©Î•† Ï∂îÏ†ï
        // Ïã§Ï†ú ÌîÑÎ°úÎçïÏÖòÏóêÏÑúÎäî Îçî Ï†ïÌôïÌïú CPU Î™®ÎãàÌÑ∞ÎßÅÏù¥ ÌïÑÏöîÌï† Ïàò ÏûàÏùå
        numGoroutines := float64(runtime.NumGoroutine())
        numCPU := float64(runtime.NumCPU())

        // Í∏∞Î≥∏Ï†ÅÏù∏ Ï∂îÏ†ï: Í≥†Î£®Ìã¥ Ïàò / CPU ÏΩîÏñ¥ Ïàò * 100
        // Ïã§Ï†úÎ°úÎäî Îçî Î≥µÏû°Ìïú Í≥ÑÏÇ∞Ïù¥ ÌïÑÏöîÌïòÏßÄÎßå, Îç∞Î™¨ ÌôòÍ≤ΩÏóêÏÑúÏùò Í∏∞Î≥∏Ï†ÅÏù∏ Ï†úÏñ¥Ïö©
        estimatedUsage := (numGoroutines / numCPU) * 10.0

        if estimatedUsage &gt; 100.0 </span><span class="cov0" title="0">{
                estimatedUsage = 100.0
        }</span>

        <span class="cov0" title="0">return estimatedUsage</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package daemon

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net"
        "os"
        "os/signal"
        "path/filepath"
        "strconv"
        "sync"
        "syscall"
        "time"
)

// DaemonServer implements the DaemonInterface using Unix Domain Socket
type DaemonServer struct {
        config     *DaemonConfig
        listener   net.Listener
        queue      QueueInterface
        running    bool
        startedAt  time.Time
        mu         sync.RWMutex
        ctx        context.Context
        cancel     context.CancelFunc
        workers    []*ScanWorker
        workerWg   sync.WaitGroup
        shutdownCh chan struct{}
}

// NewDaemonServer creates a new daemon server instance
func NewDaemonServer(config *DaemonConfig, queue QueueInterface) *DaemonServer <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = GetDefaultConfig()
        }</span>

        <span class="cov8" title="1">return &amp;DaemonServer{
                config:     config,
                queue:      queue,
                shutdownCh: make(chan struct{}),
        }</span>
}

// Start starts the daemon server
func (s *DaemonServer) Start(ctx context.Context) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov8" title="1">{
                return ErrDaemonAlreadyRunning
        }</span>

        // Check if daemon is already running
        <span class="cov8" title="1">if s.isDaemonRunning() </span><span class="cov0" title="0">{
                return ErrDaemonAlreadyRunning
        }</span>

        // Create context for cancellation
        <span class="cov8" title="1">s.ctx, s.cancel = context.WithCancel(ctx)

        // Create socket directory if it doesn't exist
        socketDir := filepath.Dir(s.getSocketPath())
        if err := os.MkdirAll(socketDir, 0755); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create socket directory: %w", err)
        }</span>

        // Remove existing socket file if it exists
        <span class="cov8" title="1">if err := s.removeSocketFile(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove existing socket: %w", err)
        }</span>

        // Create Unix socket listener
        <span class="cov8" title="1">listener, err := net.Listen("unix", s.getSocketPath())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create socket listener: %w", err)
        }</span>
        <span class="cov8" title="1">s.listener = listener

        // Set socket file permissions (owner read/write only)
        if err := os.Chmod(s.getSocketPath(), 0600); err != nil </span><span class="cov0" title="0">{
                s.listener.Close()
                return fmt.Errorf("failed to set socket permissions: %w", err)
        }</span>

        // Write PID file
        <span class="cov8" title="1">if err := s.writePIDFile(); err != nil </span><span class="cov0" title="0">{
                s.listener.Close()
                s.removeSocketFile()
                return fmt.Errorf("failed to write PID file: %w", err)
        }</span>

        <span class="cov8" title="1">s.running = true
        s.startedAt = time.Now()

        // Start worker goroutines
        s.startWorkers()

        // Start signal handler
        go s.handleSignals()

        // Start accepting connections
        go s.acceptConnections()

        return nil</span>
}

// Stop stops the daemon gracefully
func (s *DaemonServer) Stop() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !s.running </span><span class="cov8" title="1">{
                return ErrDaemonNotRunning
        }</span>

        // Signal shutdown
        <span class="cov8" title="1">close(s.shutdownCh)

        // Stop all workers
        for _, worker := range s.workers </span><span class="cov8" title="1">{
                if worker != nil </span><span class="cov8" title="1">{
                        worker.Stop()
                }</span>
        }

        // Cancel context to stop workers
        <span class="cov8" title="1">if s.cancel != nil </span><span class="cov8" title="1">{
                s.cancel()
        }</span>

        // Wait for workers to finish
        <span class="cov8" title="1">s.workerWg.Wait()

        // Close listener
        if s.listener != nil </span><span class="cov8" title="1">{
                s.listener.Close()
        }</span>

        // Clean up files
        <span class="cov8" title="1">s.removeSocketFile()
        s.removePIDFile()

        s.running = false
        return nil</span>
}

// Status returns the current daemon status
func (s *DaemonServer) Status() (*DaemonStatus, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        if !s.running </span><span class="cov8" title="1">{
                return nil, ErrDaemonNotRunning
        }</span>

        <span class="cov8" title="1">stats := s.queue.Stats()

        return &amp;DaemonStatus{
                Running:       s.running,
                PID:           os.Getpid(),
                StartedAt:     s.startedAt,
                ActiveJobs:    stats["running"],
                QueuedJobs:    stats["pending"],
                CompletedJobs: stats["completed"],
                FailedJobs:    stats["failed"],
                Workers:       len(s.workers),
        }, nil</span>
}

// IsRunning checks if the daemon is running
func (s *DaemonServer) IsRunning() bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

// EnqueueScan adds a scan job to the queue
func (s *DaemonServer) EnqueueScan(request *ScanRequest) (*Job, error) <span class="cov8" title="1">{
        if !s.IsRunning() </span><span class="cov8" title="1">{
                return nil, ErrDaemonNotRunning
        }</span>

        <span class="cov8" title="1">job := NewJob(request.Path, request.Options)
        if err := s.queue.Add(job); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to enqueue job: %w", err)
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// GetJob retrieves a job by ID
func (s *DaemonServer) GetJob(jobID string) (*Job, error) <span class="cov8" title="1">{
        if !s.IsRunning() </span><span class="cov8" title="1">{
                return nil, ErrDaemonNotRunning
        }</span>

        <span class="cov8" title="1">return s.queue.Get(jobID)</span>
}

// CancelJob cancels a job
func (s *DaemonServer) CancelJob(jobID string) error <span class="cov8" title="1">{
        if !s.IsRunning() </span><span class="cov8" title="1">{
                return ErrDaemonNotRunning
        }</span>

        <span class="cov8" title="1">return s.queue.Cancel(jobID)</span>
}

// ListJobs returns all jobs with optional status filter
func (s *DaemonServer) ListJobs(status JobStatus) ([]*Job, error) <span class="cov8" title="1">{
        if !s.IsRunning() </span><span class="cov8" title="1">{
                return nil, ErrDaemonNotRunning
        }</span>

        <span class="cov8" title="1">return s.queue.List(status)</span>
}

// ClearQueue clears all pending jobs
func (s *DaemonServer) ClearQueue() error <span class="cov8" title="1">{
        if !s.IsRunning() </span><span class="cov8" title="1">{
                return ErrDaemonNotRunning
        }</span>

        <span class="cov8" title="1">return s.queue.Clear()</span>
}

// Private helper methods

func (s *DaemonServer) getSocketPath() string <span class="cov8" title="1">{
        if filepath.IsAbs(s.config.SocketPath) </span><span class="cov8" title="1">{
                return s.config.SocketPath
        }</span>

        <span class="cov8" title="1">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return filepath.Join(os.TempDir(), ".fman", s.config.SocketPath)
        }</span>

        <span class="cov8" title="1">return filepath.Join(homeDir, ".fman", s.config.SocketPath)</span>
}

func (s *DaemonServer) getPIDPath() string <span class="cov8" title="1">{
        if filepath.IsAbs(s.config.PIDPath) </span><span class="cov8" title="1">{
                return s.config.PIDPath
        }</span>

        <span class="cov8" title="1">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return filepath.Join(os.TempDir(), ".fman", s.config.PIDPath)
        }</span>

        <span class="cov8" title="1">return filepath.Join(homeDir, ".fman", s.config.PIDPath)</span>
}

func (s *DaemonServer) isDaemonRunning() bool <span class="cov8" title="1">{
        pidPath := s.getPIDPath()

        // Check if PID file exists
        data, err := os.ReadFile(pidPath)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Parse PID
        <span class="cov8" title="1">pid, err := strconv.Atoi(string(data))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if process is still running
        <span class="cov8" title="1">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Send signal 0 to check if process exists
        <span class="cov8" title="1">err = process.Signal(syscall.Signal(0))
        return err == nil</span>
}

func (s *DaemonServer) writePIDFile() error <span class="cov8" title="1">{
        pidPath := s.getPIDPath()

        // Create directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(pidPath), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write PID to file
        <span class="cov8" title="1">pid := os.Getpid()
        return os.WriteFile(pidPath, []byte(strconv.Itoa(pid)), 0644)</span>
}

func (s *DaemonServer) removePIDFile() error <span class="cov8" title="1">{
        pidPath := s.getPIDPath()
        if _, err := os.Stat(pidPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return os.Remove(pidPath)</span>
}

func (s *DaemonServer) removeSocketFile() error <span class="cov8" title="1">{
        socketPath := s.getSocketPath()
        if _, err := os.Stat(socketPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return os.Remove(socketPath)</span>
}

func (s *DaemonServer) startWorkers() <span class="cov8" title="1">{
        s.workers = make([]*ScanWorker, s.config.MaxWorkers)

        for i := 0; i &lt; s.config.MaxWorkers; i++ </span><span class="cov8" title="1">{
                worker := NewScanWorker(i, s.queue)
                s.workers[i] = worker

                worker.Start(s.ctx, &amp;s.workerWg)
        }</span>
}

func (s *DaemonServer) handleSignals() <span class="cov8" title="1">{
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

        select </span>{
        case &lt;-sigCh:<span class="cov0" title="0">
                s.Stop()</span>
        case &lt;-s.shutdownCh:<span class="cov8" title="1">
                return</span>
        }
}

func (s *DaemonServer) acceptConnections() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov8" title="1">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">conn, err := s.listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-s.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                continue</span>
                        }
                }

                <span class="cov0" title="0">go s.handleConnection(conn)</span>
        }
}

func (s *DaemonServer) handleConnection(conn net.Conn) <span class="cov0" title="0">{
        defer conn.Close()

        decoder := json.NewDecoder(conn)
        encoder := json.NewEncoder(conn)

        for </span><span class="cov0" title="0">{
                var msg Message
                if err := decoder.Decode(&amp;msg); err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">s.sendErrorResponse(encoder, "invalid_message", fmt.Sprintf("failed to decode message: %v", err))
                        return</span>
                }

                <span class="cov0" title="0">response := s.handleMessage(&amp;msg)
                if err := encoder.Encode(response); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

func (s *DaemonServer) handleMessage(msg *Message) *Message <span class="cov8" title="1">{
        response := &amp;Message{
                Type:      MessageTypeResponse,
                ID:        msg.ID,
                Timestamp: time.Now(),
                Response:  &amp;Response{},
        }

        if msg.Request == nil </span><span class="cov8" title="1">{
                response.Response.Success = false
                response.Response.Error = "missing request"
                return response
        }</span>

        <span class="cov8" title="1">switch msg.Request.Type </span>{
        case RequestTypeScan:<span class="cov8" title="1">
                s.handleScanRequest(msg.Request, response.Response)</span>
        case RequestTypeStatus:<span class="cov8" title="1">
                s.handleStatusRequest(response.Response)</span>
        case RequestTypeJobStatus:<span class="cov8" title="1">
                s.handleJobStatusRequest(msg.Request, response.Response)</span>
        case RequestTypeJobList:<span class="cov8" title="1">
                s.handleJobListRequest(msg.Request, response.Response)</span>
        case RequestTypeJobCancel:<span class="cov8" title="1">
                s.handleJobCancelRequest(msg.Request, response.Response)</span>
        case RequestTypeQueueClear:<span class="cov8" title="1">
                s.handleQueueClearRequest(response.Response)</span>
        case RequestTypeShutdown:<span class="cov8" title="1">
                s.handleShutdownRequest(response.Response)</span>
        default:<span class="cov8" title="1">
                response.Response.Success = false
                response.Response.Error = "unknown request type"</span>
        }

        <span class="cov8" title="1">return response</span>
}

func (s *DaemonServer) handleScanRequest(req *Request, resp *Response) <span class="cov8" title="1">{
        var scanReq ScanRequest
        if err := s.parseRequestData(req.Data, &amp;scanReq); err != nil </span><span class="cov8" title="1">{
                resp.Success = false
                resp.Error = fmt.Sprintf("invalid scan request: %v", err)
                return
        }</span>

        <span class="cov8" title="1">job, err := s.EnqueueScan(&amp;scanReq)
        if err != nil </span><span class="cov0" title="0">{
                resp.Success = false
                resp.Error = fmt.Sprintf("failed to enqueue scan: %v", err)
                return
        }</span>

        <span class="cov8" title="1">resp.Success = true
        resp.Data = job</span>
}

func (s *DaemonServer) handleStatusRequest(resp *Response) <span class="cov8" title="1">{
        status, err := s.Status()
        if err != nil </span><span class="cov8" title="1">{
                resp.Success = false
                resp.Error = fmt.Sprintf("failed to get status: %v", err)
                return
        }</span>

        <span class="cov8" title="1">resp.Success = true
        resp.Data = status</span>
}

func (s *DaemonServer) handleJobStatusRequest(req *Request, resp *Response) <span class="cov8" title="1">{
        jobID, ok := req.Data.(string)
        if !ok </span><span class="cov8" title="1">{
                resp.Success = false
                resp.Error = "job ID must be a string"
                return
        }</span>

        <span class="cov8" title="1">job, err := s.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                resp.Success = false
                resp.Error = fmt.Sprintf("failed to get job: %v", err)
                return
        }</span>

        <span class="cov8" title="1">resp.Success = true
        resp.Data = job</span>
}

func (s *DaemonServer) handleJobListRequest(req *Request, resp *Response) <span class="cov8" title="1">{
        var status JobStatus
        if req.Data != nil </span><span class="cov0" title="0">{
                if statusStr, ok := req.Data.(string); ok </span><span class="cov0" title="0">{
                        status = JobStatus(statusStr)
                }</span>
        }

        <span class="cov8" title="1">jobs, err := s.ListJobs(status)
        if err != nil </span><span class="cov0" title="0">{
                resp.Success = false
                resp.Error = fmt.Sprintf("failed to list jobs: %v", err)
                return
        }</span>

        <span class="cov8" title="1">resp.Success = true
        resp.Data = jobs</span>
}

func (s *DaemonServer) handleJobCancelRequest(req *Request, resp *Response) <span class="cov8" title="1">{
        jobID, ok := req.Data.(string)
        if !ok </span><span class="cov8" title="1">{
                resp.Success = false
                resp.Error = "job ID must be a string"
                return
        }</span>

        <span class="cov8" title="1">err := s.CancelJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                resp.Success = false
                resp.Error = fmt.Sprintf("failed to cancel job: %v", err)
                return
        }</span>

        <span class="cov8" title="1">resp.Success = true</span>
}

func (s *DaemonServer) handleQueueClearRequest(resp *Response) <span class="cov8" title="1">{
        err := s.ClearQueue()
        if err != nil </span><span class="cov0" title="0">{
                resp.Success = false
                resp.Error = fmt.Sprintf("failed to clear queue: %v", err)
                return
        }</span>

        <span class="cov8" title="1">resp.Success = true</span>
}

func (s *DaemonServer) handleShutdownRequest(resp *Response) <span class="cov8" title="1">{
        resp.Success = true

        // Shutdown asynchronously to allow response to be sent
        go func() </span><span class="cov8" title="1">{
                time.Sleep(100 * time.Millisecond)
                s.Stop()
        }</span>()
}

func (s *DaemonServer) parseRequestData(data interface{}, target interface{}) error <span class="cov8" title="1">{
        if data == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("missing request data")
        }</span>

        // Convert to JSON and back to parse into target struct
        <span class="cov8" title="1">jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return json.Unmarshal(jsonData, target)</span>
}

func (s *DaemonServer) sendErrorResponse(encoder *json.Encoder, code, message string) <span class="cov0" title="0">{
        resp := &amp;Message{
                Type:      MessageTypeResponse,
                Timestamp: time.Now(),
                Response: &amp;Response{
                        Success: false,
                        Error:   message,
                },
        }
        encoder.Encode(resp)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package daemon

import (
        "context"
        "crypto/rand"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/devlikebear/fman/internal/scanner"
)

// Constants for daemon configuration
const (
        // DefaultSocketPath is the default Unix socket path
        DefaultSocketPath = "daemon.sock"
        // DefaultPIDPath is the default PID file path
        DefaultPIDPath = "daemon.pid"
        // DefaultMaxWorkers is the default number of worker goroutines
        DefaultMaxWorkers = 2
        // DefaultQueueSize is the default queue buffer size
        DefaultQueueSize = 100
)

// JobStatus represents the status of a scan job
type JobStatus string

const (
        // JobStatusPending indicates the job is waiting to be processed
        JobStatusPending JobStatus = "pending"
        // JobStatusRunning indicates the job is currently being processed
        JobStatusRunning JobStatus = "running"
        // JobStatusCompleted indicates the job has completed successfully
        JobStatusCompleted JobStatus = "completed"
        // JobStatusFailed indicates the job has failed
        JobStatusFailed JobStatus = "failed"
        // JobStatusCancelled indicates the job was cancelled
        JobStatusCancelled JobStatus = "cancelled"
)

// Job represents a scan job in the queue
type Job struct {
        ID          string               `json:"id"`
        Path        string               `json:"path"`
        Options     *scanner.ScanOptions `json:"options"`
        Status      JobStatus            `json:"status"`
        CreatedAt   time.Time            `json:"created_at"`
        StartedAt   *time.Time           `json:"started_at,omitempty"`
        CompletedAt *time.Time           `json:"completed_at,omitempty"`
        Stats       *scanner.ScanStats   `json:"stats,omitempty"`
        Error       string               `json:"error,omitempty"`
        Progress    *JobProgress         `json:"progress,omitempty"`
}

// JobProgress represents the progress of a running job
type JobProgress struct {
        FilesProcessed int    `json:"files_processed"`
        TotalFiles     int    `json:"total_files,omitempty"`
        CurrentPath    string `json:"current_path,omitempty"`
}

// ScanRequest represents a request to scan a directory
type ScanRequest struct {
        Path    string               `json:"path"`
        Options *scanner.ScanOptions `json:"options"`
}

// DaemonStatus represents the current status of the daemon
type DaemonStatus struct {
        Running       bool      `json:"running"`
        PID           int       `json:"pid"`
        StartedAt     time.Time `json:"started_at"`
        ActiveJobs    int       `json:"active_jobs"`
        QueuedJobs    int       `json:"queued_jobs"`
        CompletedJobs int       `json:"completed_jobs"`
        FailedJobs    int       `json:"failed_jobs"`
        Workers       int       `json:"workers"`
}

// MessageType represents the type of message being sent
type MessageType string

const (
        // MessageTypeRequest indicates a request message
        MessageTypeRequest MessageType = "request"
        // MessageTypeResponse indicates a response message
        MessageTypeResponse MessageType = "response"
        // MessageTypeNotification indicates a notification message
        MessageTypeNotification MessageType = "notification"
)

// RequestType represents the type of request
type RequestType string

const (
        // RequestTypeScan requests a scan operation
        RequestTypeScan RequestType = "scan"
        // RequestTypeStatus requests daemon status
        RequestTypeStatus RequestType = "status"
        // RequestTypeJobStatus requests job status
        RequestTypeJobStatus RequestType = "job_status"
        // RequestTypeJobList requests list of jobs
        RequestTypeJobList RequestType = "job_list"
        // RequestTypeJobCancel requests job cancellation
        RequestTypeJobCancel RequestType = "job_cancel"
        // RequestTypeQueueClear requests queue clearing
        RequestTypeQueueClear RequestType = "queue_clear"
        // RequestTypeShutdown requests daemon shutdown
        RequestTypeShutdown RequestType = "shutdown"
)

// Message represents a message in the communication protocol
type Message struct {
        Type      MessageType `json:"type"`
        ID        string      `json:"id"`
        Timestamp time.Time   `json:"timestamp"`
        Request   *Request    `json:"request,omitempty"`
        Response  *Response   `json:"response,omitempty"`
}

// Request represents a request message
type Request struct {
        Type RequestType `json:"type"`
        Data interface{} `json:"data,omitempty"`
}

// Response represents a response message
type Response struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
}

// DaemonConfig represents daemon configuration
type DaemonConfig struct {
        SocketPath string `json:"socket_path" yaml:"socket_path" mapstructure:"socket_path"`
        PIDPath    string `json:"pid_path" yaml:"pid_path" mapstructure:"pid_path"`
        MaxWorkers int    `json:"max_workers" yaml:"max_workers" mapstructure:"max_workers"`
        QueueSize  int    `json:"queue_size" yaml:"queue_size" mapstructure:"queue_size"`
        LogLevel   string `json:"log_level" yaml:"log_level" mapstructure:"log_level"`
}

// Common errors
var (
        // ErrDaemonNotRunning indicates the daemon is not running
        ErrDaemonNotRunning = errors.New("daemon is not running")
        // ErrDaemonAlreadyRunning indicates the daemon is already running
        ErrDaemonAlreadyRunning = errors.New("daemon is already running")
        // ErrJobNotFound indicates the requested job was not found
        ErrJobNotFound = errors.New("job not found")
        // ErrInvalidRequest indicates the request is invalid
        ErrInvalidRequest = errors.New("invalid request")
        // ErrSocketExists indicates the socket file already exists
        ErrSocketExists = errors.New("socket file already exists")
        // ErrConnectionFailed indicates connection to daemon failed
        ErrConnectionFailed = errors.New("failed to connect to daemon")
)

// DaemonInterface defines the interface for daemon operations
type DaemonInterface interface {
        // Start starts the daemon
        Start(ctx context.Context) error
        // Stop stops the daemon gracefully
        Stop() error
        // Status returns the current daemon status
        Status() (*DaemonStatus, error)
        // IsRunning checks if the daemon is running
        IsRunning() bool
        // EnqueueScan adds a scan job to the queue
        EnqueueScan(request *ScanRequest) (*Job, error)
        // GetJob retrieves a job by ID
        GetJob(jobID string) (*Job, error)
        // CancelJob cancels a job
        CancelJob(jobID string) error
        // ListJobs returns all jobs with optional status filter
        ListJobs(status JobStatus) ([]*Job, error)
        // ClearQueue clears all pending jobs
        ClearQueue() error
}

// QueueInterface defines the interface for job queue operations
type QueueInterface interface {
        // Add adds a job to the queue
        Add(job *Job) error
        // Next gets the next job from the queue (blocking)
        Next(ctx context.Context) (*Job, error)
        // Get retrieves a job by ID
        Get(jobID string) (*Job, error)
        // Update updates a job's status and data
        Update(job *Job) error
        // List returns jobs with optional status filter
        List(status JobStatus) ([]*Job, error)
        // Cancel marks a job as cancelled
        Cancel(jobID string) error
        // Clear removes all pending jobs
        Clear() error
        // Size returns the current queue size
        Size() int
        // Stats returns queue statistics
        Stats() map[string]int
}

// ClientInterface defines the interface for daemon client operations
type ClientInterface interface {
        // Connect connects to the daemon
        Connect() error
        // Disconnect disconnects from the daemon
        Disconnect() error
        // SendRequest sends a request and waits for response
        SendRequest(req *Request) (*Response, error)
        // IsConnected checks if connected to daemon
        IsConnected() bool
}

// GetDefaultConfig returns the default daemon configuration
func GetDefaultConfig() *DaemonConfig <span class="cov8" title="1">{
        homeDir, _ := os.UserHomeDir()
        fmanDir := filepath.Join(homeDir, ".fman")

        return &amp;DaemonConfig{
                SocketPath: filepath.Join(fmanDir, DefaultSocketPath),
                PIDPath:    filepath.Join(fmanDir, DefaultPIDPath),
                MaxWorkers: DefaultMaxWorkers,
                QueueSize:  DefaultQueueSize,
                LogLevel:   "info",
        }
}</span>

// NewJob creates a new job with the given parameters
func NewJob(path string, options *scanner.ScanOptions) *Job <span class="cov8" title="1">{
        return &amp;Job{
                ID:        generateJobID(),
                Path:      path,
                Options:   options,
                Status:    JobStatusPending,
                CreatedAt: time.Now(),
        }
}</span>

// generateJobID generates a unique job ID using UUID-like format
func generateJobID() string <span class="cov8" title="1">{
        // Generate 16 random bytes
        b := make([]byte, 16)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based ID if crypto/rand fails
                return fmt.Sprintf("job_%d_%d", time.Now().UnixNano(), os.Getpid())
        }</span>

        // Format as UUID-like string
        <span class="cov8" title="1">return fmt.Sprintf("job_%08x-%04x-%04x-%04x-%012x",
                b[0:4], b[4:6], b[6:8], b[8:10], b[10:16])</span>
}

// IsTerminal returns true if the job status is terminal (completed, failed, or cancelled)
func (j *Job) IsTerminal() bool <span class="cov8" title="1">{
        return j.Status == JobStatusCompleted || j.Status == JobStatusFailed || j.Status == JobStatusCancelled
}</span>

// Duration returns the job duration if completed, or duration so far if running
func (j *Job) Duration() time.Duration <span class="cov8" title="1">{
        if j.StartedAt == nil </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">endTime := time.Now()
        if j.CompletedAt != nil </span><span class="cov8" title="1">{
                endTime = *j.CompletedAt
        }</span>

        <span class="cov8" title="1">return endTime.Sub(*j.StartedAt)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package daemon

import (
        "context"
        "fmt"
        "runtime"
        "sync"
        "time"

        "github.com/devlikebear/fman/internal/db"
        "github.com/devlikebear/fman/internal/scanner"
        "github.com/spf13/afero"
)

// ScanWorker manages background scan execution
type ScanWorker struct {
        id              int
        queue           QueueInterface
        scanner         scanner.ScannerInterface
        running         bool
        ctx             context.Context
        cancel          context.CancelFunc
        mu              sync.RWMutex
        stats           WorkerStats
        maxRetries      int
        retryDelay      time.Duration
        progressChan    chan *JobProgress
        resourceMonitor *ResourceMonitor
}

// WorkerStats tracks worker performance metrics
type WorkerStats struct {
        JobsProcessed int64
        JobsSucceeded int64
        JobsFailed    int64
        TotalRuntime  time.Duration
        LastJobAt     *time.Time
        MemoryUsage   uint64
}

// NewScanWorker creates a new scan worker
func NewScanWorker(id int, queue QueueInterface) *ScanWorker <span class="cov8" title="1">{
        fs := afero.NewOsFs()
        database := db.NewDatabase(nil)
        scannerImpl := scanner.NewFileScanner(fs, database)

        // Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ ÏÑ§Ï†ï (Îç∞Î™¨Ïö© Î≥¥ÏàòÏ†Å ÏÑ§Ï†ï)
        resourceLimits := ResourceLimits{
                MaxMemoryMB:   200,                    // 200MB Î©îÎ™®Î¶¨ Ï†úÌïú
                MaxCPUPercent: 15.0,                   // 15% CPU ÏÇ¨Ïö©Î•† Ï†úÌïú
                CheckInterval: 3 * time.Second,        // 3Ï¥àÎßàÎã§ Ï≤¥ÌÅ¨
                ThrottleDelay: 200 * time.Millisecond, // Ï†úÌïú Ïãú 200ms ÎåÄÍ∏∞
        }

        return &amp;ScanWorker{
                id:              id,
                queue:           queue,
                scanner:         scannerImpl,
                maxRetries:      3,
                retryDelay:      time.Second * 5,
                progressChan:    make(chan *JobProgress, 100),
                resourceMonitor: NewResourceMonitor(resourceLimits),
        }
}</span>

// Start starts the worker in a background goroutine
func (w *ScanWorker) Start(ctx context.Context, wg *sync.WaitGroup) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if w.running </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">w.ctx, w.cancel = context.WithCancel(ctx)
        w.running = true

        // Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
        w.resourceMonitor.Start(w.ctx)

        wg.Add(1)
        go w.run(wg)</span>
}

// Stop stops the worker gracefully
func (w *ScanWorker) Stop() <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if !w.running </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if w.cancel != nil </span><span class="cov8" title="1">{
                w.cancel()
        }</span>

        // Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
        <span class="cov8" title="1">w.resourceMonitor.Stop()
        w.running = false</span>
}

// IsRunning returns whether the worker is currently running
func (w *ScanWorker) IsRunning() bool <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        return w.running
}</span>

// GetStats returns current worker statistics
func (w *ScanWorker) GetStats() WorkerStats <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        // Update memory usage
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        w.stats.MemoryUsage = m.Alloc

        return w.stats
}</span>

// GetProgressChannel returns the progress channel for monitoring
func (w *ScanWorker) GetProgressChannel() &lt;-chan *JobProgress <span class="cov8" title="1">{
        return w.progressChan
}</span>

// run is the main worker loop
func (w *ScanWorker) run(wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()
        defer close(w.progressChan)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-w.ctx.Done():<span class="cov8" title="1">
                        return</span>
                default:<span class="cov8" title="1"></span>
                }

                // Î¶¨ÏÜåÏä§ ÏÇ¨Ïö©Îüâ ÌôïÏù∏ ÌõÑ ÎåÄÍ∏∞ (ÌïÑÏöîÏãú)
                <span class="cov8" title="1">if err := w.resourceMonitor.WaitIfThrottling(w.ctx); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // Get next job from queue with timeout
                <span class="cov8" title="1">jobCtx, cancel := context.WithTimeout(w.ctx, 5*time.Second)
                job, err := w.queue.Next(jobCtx)
                cancel()

                if err != nil </span><span class="cov8" title="1">{
                        if w.ctx.Err() != nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                        // No job available, continue polling
                        <span class="cov0" title="0">continue</span>
                }

                // Process the job
                <span class="cov0" title="0">w.processJobs(job)</span>
        }
}

// processJobs handles a single job with retry logic
func (w *ScanWorker) processJobs(job *Job) <span class="cov8" title="1">{
        w.mu.Lock()
        w.stats.JobsProcessed++
        w.mu.Unlock()

        startTime := time.Now()

        // Update job status to running
        w.updateJobStatus(job, JobStatusRunning, startTime, nil, nil)

        var lastErr error
        for attempt := 0; attempt &lt;= w.maxRetries; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov8" title="1">{
                        // Wait before retry
                        select </span>{
                        case &lt;-w.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(w.retryDelay):<span class="cov8" title="1"></span>
                        }
                }

                // Execute scan with progress monitoring
                <span class="cov8" title="1">err := w.executeScan(job)
                if err == nil </span><span class="cov8" title="1">{
                        // Success
                        w.handleScanResult(job, nil, startTime)
                        w.mu.Lock()
                        w.stats.JobsSucceeded++
                        w.mu.Unlock()
                        return
                }</span>

                <span class="cov8" title="1">lastErr = err

                // Check if error is retryable
                if !w.isRetryableError(err) </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        // All retries failed
        <span class="cov8" title="1">w.handleScanResult(job, lastErr, startTime)
        w.mu.Lock()
        w.stats.JobsFailed++
        w.mu.Unlock()</span>
}

// executeScan performs the actual scan operation
func (w *ScanWorker) executeScan(job *Job) error <span class="cov8" title="1">{
        // Create a context that can be cancelled if the job is cancelled
        ctx, cancel := context.WithCancel(w.ctx)
        defer cancel()

        // Monitor for job cancellation
        go func() </span><span class="cov8" title="1">{
                ticker := time.NewTicker(time.Second)
                defer ticker.Stop()

                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                // Check if job was cancelled
                                currentJob, err := w.queue.Get(job.ID)
                                if err != nil || currentJob.Status == JobStatusCancelled </span><span class="cov0" title="0">{
                                        cancel()
                                        return
                                }</span>
                        }
                }
        }()

        // Execute the scan
        <span class="cov8" title="1">stats, err := w.scanner.ScanDirectory(ctx, job.Path, job.Options)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("scan failed: %w", err)
        }</span>

        // Update job with scan results
        <span class="cov8" title="1">job.Stats = stats
        return nil</span>
}

// updateProgress sends progress updates
func (w *ScanWorker) updateProgress(job *Job, progress *JobProgress) <span class="cov8" title="1">{
        // Update job progress in queue if supported
        job.Progress = progress
        w.queue.Update(job)

        // Send progress to channel (non-blocking)
        select </span>{
        case w.progressChan &lt;- progress:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
                // Channel is full, skip this update
        }
}

// updateJobStatus updates the job status in the queue
func (w *ScanWorker) updateJobStatus(job *Job, status JobStatus, startTime time.Time, completedTime *time.Time, err error) <span class="cov8" title="1">{
        job.Status = status

        if status == JobStatusRunning </span><span class="cov8" title="1">{
                job.StartedAt = &amp;startTime
        }</span>

        <span class="cov8" title="1">if completedTime != nil </span><span class="cov8" title="1">{
                job.CompletedAt = completedTime
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                job.Error = err.Error()
        }</span>

        <span class="cov8" title="1">w.queue.Update(job)</span>
}

// handleScanResult processes the result of a scan operation
func (w *ScanWorker) handleScanResult(job *Job, err error, startTime time.Time) <span class="cov8" title="1">{
        completedAt := time.Now()
        duration := completedAt.Sub(startTime)

        w.mu.Lock()
        w.stats.TotalRuntime += duration
        w.stats.LastJobAt = &amp;completedAt
        w.mu.Unlock()

        if err != nil </span><span class="cov8" title="1">{
                w.updateJobStatus(job, JobStatusFailed, startTime, &amp;completedAt, err)
        }</span> else<span class="cov8" title="1"> {
                w.updateJobStatus(job, JobStatusCompleted, startTime, &amp;completedAt, nil)
        }</span>

        // Send final progress update
        <span class="cov8" title="1">progress := &amp;JobProgress{
                FilesProcessed: 0,
                TotalFiles:     0,
                CurrentPath:    job.Path,
        }

        if job.Stats != nil </span><span class="cov8" title="1">{
                progress.FilesProcessed = job.Stats.FilesIndexed
                progress.TotalFiles = job.Stats.FilesIndexed
        }</span>

        <span class="cov8" title="1">w.updateProgress(job, progress)</span>
}

// isRetryableError determines if an error should trigger a retry
func (w *ScanWorker) isRetryableError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for specific error types that are retryable
        <span class="cov8" title="1">errStr := err.Error()
        retryableErrors := []string{
                "permission denied",
                "no such file or directory",
                "device or resource busy",
                "connection refused",
                "timeout",
        }

        for _, retryable := range retryableErrors </span><span class="cov8" title="1">{
                if contains(errStr, retryable) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// contains checks if a string contains a substring (case-insensitive)
func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp;
                (s == substr ||
                        (len(s) &gt; len(substr) &amp;&amp;
                                (s[:len(substr)] == substr ||
                                        s[len(s)-len(substr):] == substr ||
                                        containsInner(s, substr))))
}</span>

// containsInner checks for substring in the middle of string
func containsInner(s, substr string) bool <span class="cov8" title="1">{
        for i := 1; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package db

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/jmoiron/sqlx"
        _ "github.com/mattn/go-sqlite3"
)

// File represents a file in the database.
type File struct {
        ID         int64     `db:"id"`
        Path       string    `db:"path"`
        Name       string    `db:"name"`
        Size       int64     `db:"size"`
        ModifiedAt time.Time `db:"modified_at"`
        IndexedAt  time.Time `db:"indexed_at"`
        FileHash   string    `db:"file_hash"`
}

// SearchCriteria represents advanced search criteria for files.
type SearchCriteria struct {
        NamePattern    string     // File name pattern (LIKE query)
        MinSize        *int64     // Minimum file size in bytes
        MaxSize        *int64     // Maximum file size in bytes
        ModifiedAfter  *time.Time // Files modified after this date
        ModifiedBefore *time.Time // Files modified before this date
        SearchDir      string     // Directory to search within
        FileTypes      []string   // File extensions to include (e.g., ".jpg", ".png")
}

// DBInterface defines the interface for database operations.
type DBInterface interface {
        InitDB() error
        UpsertFile(file *File) error
        FindFilesByName(namePattern string) ([]File, error)
        FindFilesWithHashes(searchDir string, minSize int64) ([]File, error)
        FindFilesByAdvancedCriteria(criteria SearchCriteria) ([]File, error)
        Close() error
}

// Database implements DBInterface using sqlx.
type Database struct {
        db     *sqlx.DB
        dbPath string // Path to the database file
}

// NewDatabase creates a new Database instance.
// If dbConn is nil, it will attempt to connect to the default fman.db.
func NewDatabase(dbConn *sqlx.DB) DBInterface <span class="cov8" title="1">{
        return &amp;Database{db: dbConn}
}</span>

// InitDB initializes the database connection and creates the necessary tables.
func (d *Database) InitDB() error <span class="cov8" title="1">{
        if d.db != nil </span><span class="cov0" title="0">{ // If already initialized or mocked
                return nil
        }</span>

        <span class="cov8" title="1">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        <span class="cov8" title="1">dbDir := filepath.Join(home, ".fman")
        if err := os.MkdirAll(dbDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create db directory: %w", err)
        }</span>

        <span class="cov8" title="1">dbFile := filepath.Join(dbDir, "fman.db")

        dbConn, err := sqlx.Connect("sqlite3", dbFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to database: %w", err)
        }</span>
        <span class="cov8" title="1">d.db = dbConn

        // Create the files table if it doesn't exist.
        schema := `
        CREATE TABLE IF NOT EXISTS files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                path TEXT NOT NULL UNIQUE,
                name TEXT NOT NULL,
                size INTEGER NOT NULL,
                modified_at TIMESTAMP NOT NULL,
                indexed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                file_hash TEXT
        );
        `
        _, err = d.db.Exec(schema)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create table: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpsertFile inserts a new file record or updates an existing one based on the path.
func (d *Database) UpsertFile(file *File) error <span class="cov8" title="1">{
        query := `
        INSERT INTO files (path, name, size, modified_at, file_hash, indexed_at)
        VALUES (?, ?, ?, ?, ?, ?)
        ON CONFLICT(path) DO UPDATE SET
                name = excluded.name,
                size = excluded.size,
                modified_at = excluded.modified_at,
                file_hash = excluded.file_hash,
                indexed_at = excluded.indexed_at;
        `
        _, err := d.db.Exec(query, file.Path, file.Name, file.Size, file.ModifiedAt, file.FileHash, time.Now())
        return err
}</span>

// FindFilesByName searches for files by name using a LIKE query.
func (d *Database) FindFilesByName(namePattern string) ([]File, error) <span class="cov8" title="1">{
        var files []File
        query := "SELECT * FROM files WHERE name LIKE ?"
        err := d.db.Select(&amp;files, query, "%"+namePattern+"%")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return files, nil</span>
}

// FindFilesWithHashes searches for files that have hashes and meet the criteria.
func (d *Database) FindFilesWithHashes(searchDir string, minSize int64) ([]File, error) <span class="cov8" title="1">{
        var files []File
        var query string
        var args []interface{}

        if searchDir != "" </span><span class="cov8" title="1">{
                // Search within specific directory
                query = "SELECT * FROM files WHERE file_hash IS NOT NULL AND file_hash != '' AND size &gt;= ? AND path LIKE ?"
                args = []interface{}{minSize, searchDir + "%"}
        }</span> else<span class="cov8" title="1"> {
                // Search all files
                query = "SELECT * FROM files WHERE file_hash IS NOT NULL AND file_hash != '' AND size &gt;= ?"
                args = []interface{}{minSize}
        }</span>

        <span class="cov8" title="1">err := d.db.Select(&amp;files, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return files, nil</span>
}

// FindFilesByAdvancedCriteria searches for files using advanced criteria.
func (d *Database) FindFilesByAdvancedCriteria(criteria SearchCriteria) ([]File, error) <span class="cov8" title="1">{
        var files []File
        var conditions []string
        var args []interface{}

        // Base query
        query := "SELECT * FROM files WHERE 1=1"

        // Add name pattern condition
        if criteria.NamePattern != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "name LIKE ?")
                args = append(args, "%"+criteria.NamePattern+"%")
        }</span>

        // Add size conditions
        <span class="cov8" title="1">if criteria.MinSize != nil </span><span class="cov8" title="1">{
                conditions = append(conditions, "size &gt;= ?")
                args = append(args, *criteria.MinSize)
        }</span>
        <span class="cov8" title="1">if criteria.MaxSize != nil </span><span class="cov8" title="1">{
                conditions = append(conditions, "size &lt;= ?")
                args = append(args, *criteria.MaxSize)
        }</span>

        // Add modified date conditions
        <span class="cov8" title="1">if criteria.ModifiedAfter != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "modified_at &gt; ?")
                args = append(args, criteria.ModifiedAfter.Format(time.RFC3339))
        }</span>
        <span class="cov8" title="1">if criteria.ModifiedBefore != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "modified_at &lt; ?")
                args = append(args, criteria.ModifiedBefore.Format(time.RFC3339))
        }</span>

        // Add directory condition
        <span class="cov8" title="1">if criteria.SearchDir != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "path LIKE ?")
                args = append(args, criteria.SearchDir+"%")
        }</span>

        // Add file type conditions
        <span class="cov8" title="1">if len(criteria.FileTypes) &gt; 0 </span><span class="cov8" title="1">{
                var typeConditions []string
                for _, ext := range criteria.FileTypes </span><span class="cov8" title="1">{
                        typeConditions = append(typeConditions, "name LIKE ?")
                        args = append(args, "%"+ext)
                }</span>
                <span class="cov8" title="1">conditions = append(conditions, "("+strings.Join(typeConditions, " OR ")+")")</span>
        }

        // Combine all conditions
        <span class="cov8" title="1">if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                query += " AND " + strings.Join(conditions, " AND ")
        }</span>

        // Add ordering
        <span class="cov8" title="1">query += " ORDER BY modified_at DESC"

        err := d.db.Select(&amp;files, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return files, nil</span>
}

// Close closes the database connection.
func (d *Database) Close() error <span class="cov8" title="1">{
        if d.db != nil </span><span class="cov8" title="1">{
                return d.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package rules

import (
        "fmt"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/devlikebear/fman/internal/db"
)

// Evaluator evaluates rules against files
type Evaluator struct {
        verbose bool
}

// NewEvaluator creates a new rule evaluator
func NewEvaluator(verbose bool) *Evaluator <span class="cov8" title="1">{
        return &amp;Evaluator{
                verbose: verbose,
        }
}</span>

// EvaluateRule evaluates if a file matches all conditions of a rule
func (e *Evaluator) EvaluateRule(rule Rule, file db.File, baseDir string) (bool, error) <span class="cov0" title="0">{
        if !rule.Enabled </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // All conditions must be satisfied (AND logic)
        <span class="cov0" title="0">for _, condition := range rule.Conditions </span><span class="cov0" title="0">{
                matches, err := e.evaluateCondition(condition, file, baseDir)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to evaluate condition: %w", err)
                }</span>
                <span class="cov0" title="0">if !matches </span><span class="cov0" title="0">{
                        if e.verbose </span><span class="cov0" title="0">{
                                fmt.Printf("File %s does not match condition: %s %s %s\n",
                                        file.Path, condition.Type, condition.Operator, condition.Value)
                        }</span>
                        <span class="cov0" title="0">return false, nil</span>
                }
        }

        <span class="cov0" title="0">return true, nil</span>
}

// evaluateCondition evaluates a single condition against a file
func (e *Evaluator) evaluateCondition(condition Condition, file db.File, baseDir string) (bool, error) <span class="cov0" title="0">{
        switch condition.Type </span>{
        case ConditionNamePattern:<span class="cov0" title="0">
                return e.evaluateNamePattern(condition, file)</span>
        case ConditionExtension:<span class="cov0" title="0">
                return e.evaluateExtension(condition, file)</span>
        case ConditionSize:<span class="cov0" title="0">
                return e.evaluateSize(condition, file)</span>
        case ConditionAge:<span class="cov0" title="0">
                return e.evaluateAge(condition, file)</span>
        case ConditionModified:<span class="cov0" title="0">
                return e.evaluateModified(condition, file)</span>
        case ConditionPath:<span class="cov0" title="0">
                return e.evaluatePath(condition, file, baseDir)</span>
        case ConditionFileType:<span class="cov0" title="0">
                return e.evaluateFileType(condition, file)</span>
        case ConditionMimeType:<span class="cov0" title="0">
                return e.evaluateMimeType(condition, file)</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported condition type: %s", condition.Type)</span>
        }
}

// evaluateNamePattern evaluates name pattern conditions
func (e *Evaluator) evaluateNamePattern(condition Condition, file db.File) (bool, error) <span class="cov0" title="0">{
        filename := filepath.Base(file.Path)

        switch condition.Operator </span>{
        case OpContains, "":<span class="cov0" title="0">
                return strings.Contains(filename, condition.Value), nil</span>
        case OpEqual:<span class="cov0" title="0">
                return filename == condition.Value, nil</span>
        case OpNotEqual:<span class="cov0" title="0">
                return filename != condition.Value, nil</span>
        case OpStartsWith:<span class="cov0" title="0">
                return strings.HasPrefix(filename, condition.Value), nil</span>
        case OpEndsWith:<span class="cov0" title="0">
                return strings.HasSuffix(filename, condition.Value), nil</span>
        case OpMatches:<span class="cov0" title="0">
                matched, err := regexp.MatchString(condition.Value, filename)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("invalid regex pattern '%s': %w", condition.Value, err)
                }</span>
                <span class="cov0" title="0">return matched, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported operator '%s' for name_pattern", condition.Operator)</span>
        }
}

// evaluateExtension evaluates file extension conditions
func (e *Evaluator) evaluateExtension(condition Condition, file db.File) (bool, error) <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(file.Path))
        expectedExt := strings.ToLower(condition.Value)

        // Add dot if not present
        if !strings.HasPrefix(expectedExt, ".") </span><span class="cov0" title="0">{
                expectedExt = "." + expectedExt
        }</span>

        <span class="cov0" title="0">switch condition.Operator </span>{
        case OpEqual, "":<span class="cov0" title="0">
                return ext == expectedExt, nil</span>
        case OpNotEqual:<span class="cov0" title="0">
                return ext != expectedExt, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported operator '%s' for extension", condition.Operator)</span>
        }
}

// evaluateSize evaluates file size conditions
func (e *Evaluator) evaluateSize(condition Condition, file db.File) (bool, error) <span class="cov0" title="0">{
        targetSize, err := e.parseSize(condition.Value)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid size value '%s': %w", condition.Value, err)
        }</span>

        <span class="cov0" title="0">switch condition.Operator </span>{
        case OpGreaterThan, "":<span class="cov0" title="0">
                return file.Size &gt; targetSize, nil</span>
        case OpLessThan:<span class="cov0" title="0">
                return file.Size &lt; targetSize, nil</span>
        case OpGreaterThanOrEqual:<span class="cov0" title="0">
                return file.Size &gt;= targetSize, nil</span>
        case OpLessThanOrEqual:<span class="cov0" title="0">
                return file.Size &lt;= targetSize, nil</span>
        case OpEqual:<span class="cov0" title="0">
                return file.Size == targetSize, nil</span>
        case OpNotEqual:<span class="cov0" title="0">
                return file.Size != targetSize, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported operator '%s' for size", condition.Operator)</span>
        }
}

// evaluateAge evaluates file age conditions
func (e *Evaluator) evaluateAge(condition Condition, file db.File) (bool, error) <span class="cov0" title="0">{
        targetAge, err := e.parseDuration(condition.Value)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid age value '%s': %w", condition.Value, err)
        }</span>

        <span class="cov0" title="0">fileAge := time.Since(file.ModifiedAt)

        switch condition.Operator </span>{
        case OpGreaterThan, "":<span class="cov0" title="0">
                return fileAge &gt; targetAge, nil</span>
        case OpLessThan:<span class="cov0" title="0">
                return fileAge &lt; targetAge, nil</span>
        case OpGreaterThanOrEqual:<span class="cov0" title="0">
                return fileAge &gt;= targetAge, nil</span>
        case OpLessThanOrEqual:<span class="cov0" title="0">
                return fileAge &lt;= targetAge, nil</span>
        case OpEqual:<span class="cov0" title="0">
                return fileAge == targetAge, nil</span>
        case OpNotEqual:<span class="cov0" title="0">
                return fileAge != targetAge, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported operator '%s' for age", condition.Operator)</span>
        }
}

// evaluateModified evaluates file modification date conditions
func (e *Evaluator) evaluateModified(condition Condition, file db.File) (bool, error) <span class="cov0" title="0">{
        targetTime, err := e.parseTime(condition.Value)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid modified value '%s': %w", condition.Value, err)
        }</span>

        <span class="cov0" title="0">switch condition.Operator </span>{
        case OpGreaterThan, "":<span class="cov0" title="0">
                return file.ModifiedAt.After(targetTime), nil</span>
        case OpLessThan:<span class="cov0" title="0">
                return file.ModifiedAt.Before(targetTime), nil</span>
        case OpGreaterThanOrEqual:<span class="cov0" title="0">
                return file.ModifiedAt.After(targetTime) || file.ModifiedAt.Equal(targetTime), nil</span>
        case OpLessThanOrEqual:<span class="cov0" title="0">
                return file.ModifiedAt.Before(targetTime) || file.ModifiedAt.Equal(targetTime), nil</span>
        case OpEqual:<span class="cov0" title="0">
                return file.ModifiedAt.Equal(targetTime), nil</span>
        case OpNotEqual:<span class="cov0" title="0">
                return !file.ModifiedAt.Equal(targetTime), nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported operator '%s' for modified", condition.Operator)</span>
        }
}

// evaluatePath evaluates file path conditions
func (e *Evaluator) evaluatePath(condition Condition, file db.File, baseDir string) (bool, error) <span class="cov0" title="0">{
        path := file.Path
        if baseDir != "" </span><span class="cov0" title="0">{
                // Make path relative to base directory if possible
                if strings.HasPrefix(path, baseDir) </span><span class="cov0" title="0">{
                        path = strings.TrimPrefix(path, baseDir)
                        path = strings.TrimPrefix(path, "/")
                }</span>
        }

        <span class="cov0" title="0">switch condition.Operator </span>{
        case OpContains, "":<span class="cov0" title="0">
                return strings.Contains(path, condition.Value), nil</span>
        case OpEqual:<span class="cov0" title="0">
                return path == condition.Value, nil</span>
        case OpNotEqual:<span class="cov0" title="0">
                return path != condition.Value, nil</span>
        case OpStartsWith:<span class="cov0" title="0">
                return strings.HasPrefix(path, condition.Value), nil</span>
        case OpEndsWith:<span class="cov0" title="0">
                return strings.HasSuffix(path, condition.Value), nil</span>
        case OpMatches:<span class="cov0" title="0">
                matched, err := regexp.MatchString(condition.Value, path)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("invalid regex pattern '%s': %w", condition.Value, err)
                }</span>
                <span class="cov0" title="0">return matched, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported operator '%s' for path", condition.Operator)</span>
        }
}

// evaluateFileType evaluates file type conditions
func (e *Evaluator) evaluateFileType(condition Condition, file db.File) (bool, error) <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(file.Path))

        // Define file type mappings
        fileTypes := map[string][]string{
                "image":    {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp", ".svg"},
                "video":    {".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm", ".m4v"},
                "audio":    {".mp3", ".wav", ".flac", ".aac", ".ogg", ".wma", ".m4a"},
                "document": {".pdf", ".doc", ".docx", ".txt", ".rtf", ".odt", ".pages"},
                "archive":  {".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", ".xz"},
                "code":     {".go", ".py", ".js", ".ts", ".java", ".cpp", ".c", ".h"},
        }

        targetType := strings.ToLower(condition.Value)

        // Check if it's a predefined type
        if extensions, exists := fileTypes[targetType]; exists </span><span class="cov0" title="0">{
                for _, validExt := range extensions </span><span class="cov0" title="0">{
                        if ext == validExt </span><span class="cov0" title="0">{
                                switch condition.Operator </span>{
                                case OpEqual, "":<span class="cov0" title="0">
                                        return true, nil</span>
                                case OpNotEqual:<span class="cov0" title="0">
                                        return false, nil</span>
                                }
                        }
                }
                <span class="cov0" title="0">switch condition.Operator </span>{
                case OpEqual, "":<span class="cov0" title="0">
                        return false, nil</span>
                case OpNotEqual:<span class="cov0" title="0">
                        return true, nil</span>
                }
        }

        // Check if it's a specific extension
        <span class="cov0" title="0">if strings.HasPrefix(targetType, ".") </span><span class="cov0" title="0">{
                switch condition.Operator </span>{
                case OpEqual, "":<span class="cov0" title="0">
                        return ext == targetType, nil</span>
                case OpNotEqual:<span class="cov0" title="0">
                        return ext != targetType, nil</span>
                }
        }

        <span class="cov0" title="0">return false, fmt.Errorf("unknown file type: %s", condition.Value)</span>
}

// evaluateMimeType evaluates MIME type conditions (placeholder for future implementation)
func (e *Evaluator) evaluateMimeType(condition Condition, file db.File) (bool, error) <span class="cov0" title="0">{
        // This would require file content analysis
        // For now, return false as it's not implemented
        return false, fmt.Errorf("mime_type condition not yet implemented")
}</span>

// parseSize parses size strings like "100M", "1G", etc.
func (e *Evaluator) parseSize(sizeStr string) (int64, error) <span class="cov0" title="0">{
        if sizeStr == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("empty size string")
        }</span>

        // Remove any whitespace
        <span class="cov0" title="0">sizeStr = strings.TrimSpace(sizeStr)

        // Handle units
        multiplier := int64(1)
        unit := strings.ToUpper(sizeStr[len(sizeStr)-1:])

        switch unit </span>{
        case "K":<span class="cov0" title="0">
                multiplier = 1024
                sizeStr = sizeStr[:len(sizeStr)-1]</span>
        case "M":<span class="cov0" title="0">
                multiplier = 1024 * 1024
                sizeStr = sizeStr[:len(sizeStr)-1]</span>
        case "G":<span class="cov0" title="0">
                multiplier = 1024 * 1024 * 1024
                sizeStr = sizeStr[:len(sizeStr)-1]</span>
        case "T":<span class="cov0" title="0">
                multiplier = 1024 * 1024 * 1024 * 1024
                sizeStr = sizeStr[:len(sizeStr)-1]</span>
        }

        // Parse the numeric part
        <span class="cov0" title="0">value, err := strconv.ParseFloat(sizeStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid size format: %w", err)
        }</span>

        <span class="cov0" title="0">return int64(value * float64(multiplier)), nil</span>
}

// parseDuration parses duration strings like "30d", "1w", etc.
func (e *Evaluator) parseDuration(durationStr string) (time.Duration, error) <span class="cov0" title="0">{
        if durationStr == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("empty duration string")
        }</span>

        // Remove any whitespace
        <span class="cov0" title="0">durationStr = strings.TrimSpace(durationStr)

        // Extract unit
        unit := strings.ToLower(durationStr[len(durationStr)-1:])
        valueStr := durationStr[:len(durationStr)-1]

        value, err := strconv.ParseFloat(valueStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid duration format: %w", err)
        }</span>

        <span class="cov0" title="0">switch unit </span>{
        case "s":<span class="cov0" title="0">
                return time.Duration(value * float64(time.Second)), nil</span>
        case "m":<span class="cov0" title="0">
                return time.Duration(value * float64(time.Minute)), nil</span>
        case "h":<span class="cov0" title="0">
                return time.Duration(value * float64(time.Hour)), nil</span>
        case "d":<span class="cov0" title="0">
                return time.Duration(value * float64(24*time.Hour)), nil</span>
        case "w":<span class="cov0" title="0">
                return time.Duration(value * float64(7*24*time.Hour)), nil</span>
        case "y":<span class="cov0" title="0">
                return time.Duration(value * float64(365*24*time.Hour)), nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unknown duration unit: %s", unit)</span>
        }
}

// parseTime parses time strings in various formats
func (e *Evaluator) parseTime(timeStr string) (time.Time, error) <span class="cov0" title="0">{
        if timeStr == "" </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("empty time string")
        }</span>

        // Try different time formats
        <span class="cov0" title="0">formats := []string{
                "2006-01-02",
                "2006-01-02 15:04:05",
                "2006-01-02T15:04:05Z",
                "2006-01-02T15:04:05-07:00",
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if t, err := time.Parse(format, timeStr); err == nil </span><span class="cov0" title="0">{
                        return t, nil
                }</span>
        }

        // Try relative time (like "+30d" or "-1w")
        <span class="cov0" title="0">if strings.HasPrefix(timeStr, "+") || strings.HasPrefix(timeStr, "-") </span><span class="cov0" title="0">{
                sign := 1
                if strings.HasPrefix(timeStr, "-") </span><span class="cov0" title="0">{
                        sign = -1
                }</span>

                <span class="cov0" title="0">durationStr := timeStr[1:]
                duration, err := e.parseDuration(durationStr)
                if err != nil </span><span class="cov0" title="0">{
                        return time.Time{}, fmt.Errorf("invalid relative time: %w", err)
                }</span>

                <span class="cov0" title="0">return time.Now().Add(time.Duration(sign) * duration), nil</span>
        }

        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("unable to parse time: %s", timeStr)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package rules

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/devlikebear/fman/internal/db"
)

// Executor executes rule actions on files
type Executor struct {
        dryRun  bool
        verbose bool
        confirm bool
}

// NewExecutor creates a new rule executor
func NewExecutor(dryRun, verbose, confirm bool) *Executor <span class="cov8" title="1">{
        return &amp;Executor{
                dryRun:  dryRun,
                verbose: verbose,
                confirm: confirm,
        }
}</span>

// ExecuteRule executes all actions for a rule on a matching file
func (ex *Executor) ExecuteRule(rule Rule, file db.File, baseDir string) ExecutionResult <span class="cov0" title="0">{
        result := ExecutionResult{
                Rule:    &amp;rule,
                File:    file,
                Actions: []ActionResult{},
                Success: true,
        }

        if ex.verbose </span><span class="cov0" title="0">{
                fmt.Printf("Executing rule '%s' on file: %s\n", rule.Name, file.Path)
        }</span>

        // Execute all actions for this rule
        <span class="cov0" title="0">for _, action := range rule.Actions </span><span class="cov0" title="0">{
                actionResult := ex.executeAction(action, file, baseDir)
                result.Actions = append(result.Actions, actionResult)

                if !actionResult.Success &amp;&amp; !actionResult.Skipped </span><span class="cov0" title="0">{
                        result.Success = false
                        result.Error = actionResult.Error
                        if ex.verbose </span><span class="cov0" title="0">{
                                fmt.Printf("Action failed: %v\n", actionResult.Error)
                        }</span>
                        <span class="cov0" title="0">break</span> // Stop on first failure
                }
        }

        <span class="cov0" title="0">return result</span>
}

// executeAction executes a single action
func (ex *Executor) executeAction(action Action, file db.File, baseDir string) ActionResult <span class="cov0" title="0">{
        result := ActionResult{
                Action:  action,
                Source:  file.Path,
                Success: false,
        }

        // Handle confirmation if required
        if (action.Confirm || ex.confirm) &amp;&amp; !ex.dryRun </span><span class="cov0" title="0">{
                if !ex.askConfirmation(action, file) </span><span class="cov0" title="0">{
                        result.Skipped = true
                        result.SkipReason = "user cancelled"
                        return result
                }</span>
        }

        <span class="cov0" title="0">switch action.Type </span>{
        case ActionMove:<span class="cov0" title="0">
                return ex.executeMove(action, file, baseDir)</span>
        case ActionCopy:<span class="cov0" title="0">
                return ex.executeCopy(action, file, baseDir)</span>
        case ActionDelete:<span class="cov0" title="0">
                return ex.executeDelete(action, file)</span>
        case ActionRename:<span class="cov0" title="0">
                return ex.executeRename(action, file, baseDir)</span>
        case ActionLink:<span class="cov0" title="0">
                return ex.executeLink(action, file, baseDir)</span>
        default:<span class="cov0" title="0">
                result.Error = fmt.Errorf("unsupported action type: %s", action.Type)
                return result</span>
        }
}

// executeMove executes a move action
func (ex *Executor) executeMove(action Action, file db.File, baseDir string) ActionResult <span class="cov0" title="0">{
        result := ActionResult{
                Action: action,
                Source: file.Path,
        }

        destination, err := ex.resolveDestination(action, file, baseDir)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to resolve destination: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">result.Destination = destination

        if ex.dryRun </span><span class="cov0" title="0">{
                if ex.verbose </span><span class="cov0" title="0">{
                        fmt.Printf("DRY RUN: Would move %s to %s\n", file.Path, destination)
                }</span>
                <span class="cov0" title="0">result.Success = true
                return result</span>
        }

        // Create backup if requested
        <span class="cov0" title="0">if action.Backup </span><span class="cov0" title="0">{
                if err := ex.createBackup(file.Path); err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("failed to create backup: %w", err)
                        return result
                }</span>
        }

        // Ensure destination directory exists
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(destination), 0755); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create destination directory: %w", err)
                return result
        }</span>

        // Check if destination already exists
        <span class="cov0" title="0">if _, err := os.Stat(destination); err == nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("destination already exists: %s", destination)
                return result
        }</span>

        // Perform the move
        <span class="cov0" title="0">if err := os.Rename(file.Path, destination); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to move file: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">if ex.verbose </span><span class="cov0" title="0">{
                fmt.Printf("Moved %s to %s\n", file.Path, destination)
        }</span>

        <span class="cov0" title="0">result.Success = true
        return result</span>
}

// executeCopy executes a copy action
func (ex *Executor) executeCopy(action Action, file db.File, baseDir string) ActionResult <span class="cov0" title="0">{
        result := ActionResult{
                Action: action,
                Source: file.Path,
        }

        destination, err := ex.resolveDestination(action, file, baseDir)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to resolve destination: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">result.Destination = destination

        if ex.dryRun </span><span class="cov0" title="0">{
                if ex.verbose </span><span class="cov0" title="0">{
                        fmt.Printf("DRY RUN: Would copy %s to %s\n", file.Path, destination)
                }</span>
                <span class="cov0" title="0">result.Success = true
                return result</span>
        }

        // Ensure destination directory exists
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(destination), 0755); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create destination directory: %w", err)
                return result
        }</span>

        // Check if destination already exists
        <span class="cov0" title="0">if _, err := os.Stat(destination); err == nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("destination already exists: %s", destination)
                return result
        }</span>

        // Perform the copy
        <span class="cov0" title="0">if err := ex.copyFile(file.Path, destination); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to copy file: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">if ex.verbose </span><span class="cov0" title="0">{
                fmt.Printf("Copied %s to %s\n", file.Path, destination)
        }</span>

        <span class="cov0" title="0">result.Success = true
        return result</span>
}

// executeDelete executes a delete action
func (ex *Executor) executeDelete(action Action, file db.File) ActionResult <span class="cov0" title="0">{
        result := ActionResult{
                Action:      action,
                Source:      file.Path,
                Destination: "", // No destination for delete
        }

        if ex.dryRun </span><span class="cov0" title="0">{
                if ex.verbose </span><span class="cov0" title="0">{
                        fmt.Printf("DRY RUN: Would delete %s\n", file.Path)
                }</span>
                <span class="cov0" title="0">result.Success = true
                return result</span>
        }

        // Create backup if requested
        <span class="cov0" title="0">if action.Backup </span><span class="cov0" title="0">{
                if err := ex.createBackup(file.Path); err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("failed to create backup: %w", err)
                        return result
                }</span>
        }

        // Perform the deletion
        <span class="cov0" title="0">if err := os.Remove(file.Path); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to delete file: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">if ex.verbose </span><span class="cov0" title="0">{
                fmt.Printf("Deleted %s\n", file.Path)
        }</span>

        <span class="cov0" title="0">result.Success = true
        return result</span>
}

// executeRename executes a rename action
func (ex *Executor) executeRename(action Action, file db.File, baseDir string) ActionResult <span class="cov0" title="0">{
        result := ActionResult{
                Action: action,
                Source: file.Path,
        }

        // For rename, destination should be just the new filename
        newName := action.Destination
        if action.Template != "" </span><span class="cov0" title="0">{
                var err error
                newName, err = ex.resolveTemplate(action.Template, file)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("failed to resolve template: %w", err)
                        return result
                }</span>
        }

        <span class="cov0" title="0">destination := filepath.Join(filepath.Dir(file.Path), newName)
        result.Destination = destination

        if ex.dryRun </span><span class="cov0" title="0">{
                if ex.verbose </span><span class="cov0" title="0">{
                        fmt.Printf("DRY RUN: Would rename %s to %s\n", file.Path, destination)
                }</span>
                <span class="cov0" title="0">result.Success = true
                return result</span>
        }

        // Check if destination already exists
        <span class="cov0" title="0">if _, err := os.Stat(destination); err == nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("destination already exists: %s", destination)
                return result
        }</span>

        // Create backup if requested
        <span class="cov0" title="0">if action.Backup </span><span class="cov0" title="0">{
                if err := ex.createBackup(file.Path); err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("failed to create backup: %w", err)
                        return result
                }</span>
        }

        // Perform the rename
        <span class="cov0" title="0">if err := os.Rename(file.Path, destination); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to rename file: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">if ex.verbose </span><span class="cov0" title="0">{
                fmt.Printf("Renamed %s to %s\n", file.Path, destination)
        }</span>

        <span class="cov0" title="0">result.Success = true
        return result</span>
}

// executeLink executes a link action (symbolic link)
func (ex *Executor) executeLink(action Action, file db.File, baseDir string) ActionResult <span class="cov0" title="0">{
        result := ActionResult{
                Action: action,
                Source: file.Path,
        }

        destination, err := ex.resolveDestination(action, file, baseDir)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to resolve destination: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">result.Destination = destination

        if ex.dryRun </span><span class="cov0" title="0">{
                if ex.verbose </span><span class="cov0" title="0">{
                        fmt.Printf("DRY RUN: Would create link from %s to %s\n", destination, file.Path)
                }</span>
                <span class="cov0" title="0">result.Success = true
                return result</span>
        }

        // Ensure destination directory exists
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(destination), 0755); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create destination directory: %w", err)
                return result
        }</span>

        // Check if destination already exists
        <span class="cov0" title="0">if _, err := os.Stat(destination); err == nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("destination already exists: %s", destination)
                return result
        }</span>

        // Create symbolic link
        <span class="cov0" title="0">if err := os.Symlink(file.Path, destination); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create symbolic link: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">if ex.verbose </span><span class="cov0" title="0">{
                fmt.Printf("Created symbolic link from %s to %s\n", destination, file.Path)
        }</span>

        <span class="cov0" title="0">result.Success = true
        return result</span>
}

// resolveDestination resolves the destination path for an action
func (ex *Executor) resolveDestination(action Action, file db.File, baseDir string) (string, error) <span class="cov0" title="0">{
        var destination string

        if action.Template != "" </span><span class="cov0" title="0">{
                var err error
                destination, err = ex.resolveTemplate(action.Template, file)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        } else<span class="cov0" title="0"> {
                destination = action.Destination
        }</span>

        // Expand home directory
        <span class="cov0" title="0">if strings.HasPrefix(destination, "~/") </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get home directory: %w", err)
                }</span>
                <span class="cov0" title="0">destination = filepath.Join(homeDir, destination[2:])</span>
        }

        // If destination is a directory, append the filename
        <span class="cov0" title="0">if strings.HasSuffix(destination, "/") || strings.HasSuffix(destination, "\\") </span><span class="cov0" title="0">{
                filename := filepath.Base(file.Path)
                destination = filepath.Join(destination, filename)
        }</span>

        <span class="cov0" title="0">return destination, nil</span>
}

// resolveTemplate resolves template variables in a string
func (ex *Executor) resolveTemplate(template string, file db.File) (string, error) <span class="cov0" title="0">{
        result := template

        // Replace common template variables
        replacements := map[string]string{
                "{filename}":  filepath.Base(file.Path),
                "{basename}":  strings.TrimSuffix(filepath.Base(file.Path), filepath.Ext(file.Path)),
                "{ext}":       filepath.Ext(file.Path),
                "{dir}":       filepath.Dir(file.Path),
                "{size}":      fmt.Sprintf("%d", file.Size),
                "{year}":      file.ModifiedAt.Format("2006"),
                "{month}":     file.ModifiedAt.Format("01"),
                "{day}":       file.ModifiedAt.Format("02"),
                "{date}":      file.ModifiedAt.Format("2006-01-02"),
                "{timestamp}": file.ModifiedAt.Format("20060102-150405"),
        }

        for placeholder, value := range replacements </span><span class="cov0" title="0">{
                result = strings.ReplaceAll(result, placeholder, value)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// createBackup creates a backup of a file
func (ex *Executor) createBackup(filePath string) error <span class="cov0" title="0">{
        backupPath := filePath + ".backup." + time.Now().Format("20060102-150405")

        if ex.verbose </span><span class="cov0" title="0">{
                fmt.Printf("Creating backup: %s\n", backupPath)
        }</span>

        <span class="cov0" title="0">return ex.copyFile(filePath, backupPath)</span>
}

// copyFile copies a file from src to dst
func (ex *Executor) copyFile(src, dst string) error <span class="cov0" title="0">{
        sourceFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sourceFile.Close()

        destFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer destFile.Close()

        // Copy file contents
        buffer := make([]byte, 64*1024) // 64KB buffer
        for </span><span class="cov0" title="0">{
                n, err := sourceFile.Read(buffer)
                if n &gt; 0 </span><span class="cov0" title="0">{
                        if _, writeErr := destFile.Write(buffer[:n]); writeErr != nil </span><span class="cov0" title="0">{
                                return writeErr
                        }</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if err.Error() == "EOF" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }
        }

        // Copy file permissions
        <span class="cov0" title="0">sourceInfo, err := sourceFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.Chmod(dst, sourceInfo.Mode())</span>
}

// askConfirmation asks the user for confirmation
func (ex *Executor) askConfirmation(action Action, file db.File) bool <span class="cov0" title="0">{
        fmt.Printf("Execute %s action on %s? (y/N): ", action.Type, file.Path)

        scanner := bufio.NewScanner(os.Stdin)
        if scanner.Scan() </span><span class="cov0" title="0">{
                response := strings.ToLower(strings.TrimSpace(scanner.Text()))
                return response == "y" || response == "yes"
        }</span>

        <span class="cov0" title="0">return false</span> // Default to no
}

// GetExecutorSettings returns the current executor settings for testing
func (ex *Executor) GetExecutorSettings() (bool, bool, bool) <span class="cov8" title="1">{
        return ex.dryRun, ex.verbose, ex.confirm
}</span>

// ValidateActionType checks if an action type is valid
func ValidateActionType(actionType ActionType) bool <span class="cov8" title="1">{
        switch actionType </span>{
        case ActionMove, ActionCopy, ActionDelete, ActionRename, ActionLink:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package rules

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "gopkg.in/yaml.v3"
)

// Manager handles rule configuration management
type Manager struct {
        configPath string
        config     *RulesConfig
}

// NewManager creates a new rules manager
func NewManager(configDir string) *Manager <span class="cov8" title="1">{
        return &amp;Manager{
                configPath: filepath.Join(configDir, DefaultRulesFile),
        }
}</span>

// LoadRules loads rules from the configuration file
func (m *Manager) LoadRules() error <span class="cov8" title="1">{
        if _, err := os.Stat(m.configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                // Create default configuration if file doesn't exist
                m.config = &amp;RulesConfig{
                        Version: DefaultVersion,
                        Rules:   []Rule{},
                }
                return m.SaveRules()
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(m.configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read rules file: %w", err)
        }</span>

        <span class="cov8" title="1">config := &amp;RulesConfig{}
        if err := yaml.Unmarshal(data, config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse rules file: %w", err)
        }</span>

        <span class="cov8" title="1">m.config = config
        return nil</span>
}

// SaveRules saves rules to the configuration file
func (m *Manager) SaveRules() error <span class="cov8" title="1">{
        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(m.configPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov8" title="1">data, err := yaml.Marshal(m.config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal rules: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(m.configPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write rules file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetRules returns all rules
func (m *Manager) GetRules() []Rule <span class="cov8" title="1">{
        if m.config == nil </span><span class="cov0" title="0">{
                return []Rule{}
        }</span>
        <span class="cov8" title="1">return m.config.Rules</span>
}

// GetEnabledRules returns only enabled rules
func (m *Manager) GetEnabledRules() []Rule <span class="cov8" title="1">{
        var enabled []Rule
        for _, rule := range m.GetRules() </span><span class="cov8" title="1">{
                if rule.Enabled </span><span class="cov8" title="1">{
                        enabled = append(enabled, rule)
                }</span>
        }
        <span class="cov8" title="1">return enabled</span>
}

// GetRule returns a rule by name
func (m *Manager) GetRule(name string) (*Rule, error) <span class="cov8" title="1">{
        for i, rule := range m.config.Rules </span><span class="cov8" title="1">{
                if rule.Name == name </span><span class="cov8" title="1">{
                        return &amp;m.config.Rules[i], nil
                }</span>
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("rule '%s' not found", name)</span>
}

// AddRule adds a new rule
func (m *Manager) AddRule(rule Rule) error <span class="cov8" title="1">{
        // Check if rule name already exists
        if _, err := m.GetRule(rule.Name); err == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("rule '%s' already exists", rule.Name)
        }</span>

        // Set timestamps
        <span class="cov8" title="1">now := time.Now()
        rule.CreatedAt = now
        rule.UpdatedAt = now

        // Add rule
        m.config.Rules = append(m.config.Rules, rule)
        return m.SaveRules()</span>
}

// UpdateRule updates an existing rule
func (m *Manager) UpdateRule(name string, updatedRule Rule) error <span class="cov8" title="1">{
        for i, rule := range m.config.Rules </span><span class="cov8" title="1">{
                if rule.Name == name </span><span class="cov8" title="1">{
                        // Preserve creation time, update modification time
                        updatedRule.CreatedAt = rule.CreatedAt
                        updatedRule.UpdatedAt = time.Now()
                        updatedRule.Name = name // Ensure name doesn't change

                        m.config.Rules[i] = updatedRule
                        return m.SaveRules()
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("rule '%s' not found", name)</span>
}

// RemoveRule removes a rule by name
func (m *Manager) RemoveRule(name string) error <span class="cov8" title="1">{
        for i, rule := range m.config.Rules </span><span class="cov8" title="1">{
                if rule.Name == name </span><span class="cov8" title="1">{
                        // Remove rule from slice
                        m.config.Rules = append(m.config.Rules[:i], m.config.Rules[i+1:]...)
                        return m.SaveRules()
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("rule '%s' not found", name)</span>
}

// EnableRule enables a rule
func (m *Manager) EnableRule(name string) error <span class="cov8" title="1">{
        rule, err := m.GetRule(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rule.Enabled = true
        rule.UpdatedAt = time.Now()
        return m.SaveRules()</span>
}

// DisableRule disables a rule
func (m *Manager) DisableRule(name string) error <span class="cov8" title="1">{
        rule, err := m.GetRule(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rule.Enabled = false
        rule.UpdatedAt = time.Now()
        return m.SaveRules()</span>
}

// ValidateRule validates a rule's configuration
func (m *Manager) ValidateRule(rule Rule) error <span class="cov8" title="1">{
        if rule.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("rule name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(rule.Conditions) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("rule must have at least one condition")
        }</span>

        <span class="cov8" title="1">if len(rule.Actions) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("rule must have at least one action")
        }</span>

        // Validate conditions
        <span class="cov8" title="1">for i, condition := range rule.Conditions </span><span class="cov8" title="1">{
                if err := m.validateCondition(condition); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition %d: %w", i+1, err)
                }</span>
        }

        // Validate actions
        <span class="cov8" title="1">for i, action := range rule.Actions </span><span class="cov8" title="1">{
                if err := m.validateAction(action); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("action %d: %w", i+1, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateCondition validates a single condition
func (m *Manager) validateCondition(condition Condition) error <span class="cov8" title="1">{
        validTypes := map[ConditionType]bool{
                ConditionNamePattern: true,
                ConditionExtension:   true,
                ConditionSize:        true,
                ConditionAge:         true,
                ConditionModified:    true,
                ConditionPath:        true,
                ConditionFileType:    true,
                ConditionMimeType:    true,
        }

        if !validTypes[condition.Type] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid condition type: %s", condition.Type)
        }</span>

        <span class="cov8" title="1">if condition.Value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("condition value cannot be empty")
        }</span>

        // Validate operators for specific condition types
        <span class="cov8" title="1">switch condition.Type </span>{
        case ConditionSize, ConditionAge:<span class="cov0" title="0">
                validOps := map[string]bool{
                        OpGreaterThan: true, OpLessThan: true,
                        OpGreaterThanOrEqual: true, OpLessThanOrEqual: true,
                        OpEqual: true, OpNotEqual: true,
                }
                if condition.Operator != "" &amp;&amp; !validOps[condition.Operator] </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid operator '%s' for condition type %s", condition.Operator, condition.Type)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateAction validates a single action
func (m *Manager) validateAction(action Action) error <span class="cov8" title="1">{
        validTypes := map[ActionType]bool{
                ActionMove:   true,
                ActionCopy:   true,
                ActionDelete: true,
                ActionRename: true,
                ActionLink:   true,
        }

        if !validTypes[action.Type] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid action type: %s", action.Type)
        }</span>

        // Actions that require destination
        <span class="cov8" title="1">if action.Type == ActionMove || action.Type == ActionCopy || action.Type == ActionLink </span><span class="cov8" title="1">{
                if action.Destination == "" &amp;&amp; action.Template == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("action type '%s' requires destination or template", action.Type)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetConfigPath returns the path to the rules configuration file
func (m *Manager) GetConfigPath() string <span class="cov8" title="1">{
        return m.configPath
}</span>

// CreateExampleRules creates example rules for demonstration
func (m *Manager) CreateExampleRules() error <span class="cov8" title="1">{
        examples := []Rule{
                {
                        Name:        "archive-old-screenshots",
                        Description: "Move screenshots older than 30 days to archive folder",
                        Enabled:     false, // Disabled by default for safety
                        Conditions: []Condition{
                                {
                                        Type:     ConditionNamePattern,
                                        Operator: OpContains,
                                        Value:    "Screenshot",
                                },
                                {
                                        Type:     ConditionAge,
                                        Operator: OpGreaterThan,
                                        Value:    "30d",
                                },
                        },
                        Actions: []Action{
                                {
                                        Type:        ActionMove,
                                        Destination: "~/Pictures/Archive/Screenshots/",
                                        Backup:      true,
                                        Confirm:     true,
                                },
                        },
                },
                {
                        Name:        "cleanup-large-temp-files",
                        Description: "Delete temporary files larger than 100MB and older than 7 days",
                        Enabled:     false,
                        Conditions: []Condition{
                                {
                                        Type:     ConditionPath,
                                        Operator: OpContains,
                                        Value:    "/tmp/",
                                },
                                {
                                        Type:     ConditionSize,
                                        Operator: OpGreaterThan,
                                        Value:    "100M",
                                },
                                {
                                        Type:     ConditionAge,
                                        Operator: OpGreaterThan,
                                        Value:    "7d",
                                },
                        },
                        Actions: []Action{
                                {
                                        Type:    ActionDelete,
                                        Confirm: true,
                                },
                        },
                },
        }

        for _, rule := range examples </span><span class="cov8" title="1">{
                // Only add if it doesn't exist
                if _, err := m.GetRule(rule.Name); err != nil </span><span class="cov8" title="1">{
                        if err := m.AddRule(rule); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add example rule '%s': %w", rule.Name, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package scanner

import (
        "context"
        "crypto/sha256"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "time"

        "github.com/devlikebear/fman/internal/db"
        "github.com/devlikebear/fman/internal/utils"
        "github.com/spf13/afero"
)

// ScanStats holds statistics about the scanning process
type ScanStats struct {
        FilesIndexed       int
        DirectoriesSkipped int
        PermissionErrors   int
        SkippedPaths       []string
}

// ScanOptions contains options for scanning
type ScanOptions struct {
        Verbose       bool
        ForceSudo     bool
        ThrottleDelay time.Duration // ÌååÏùº Í∞Ñ Ï≤òÎ¶¨ ÏßÄÏó∞ÏãúÍ∞Ñ
        MaxFileSize   int64         // Ìï¥Ïãú Í≥ÑÏÇ∞ ÏµúÎåÄ ÌååÏùº ÌÅ¨Í∏∞ (Î∞îÏù¥Ìä∏)
}

// ScannerInterface defines the interface for file scanning operations
type ScannerInterface interface {
        ScanDirectory(ctx context.Context, rootDir string, options *ScanOptions) (*ScanStats, error)
}

// FileScanner implements the ScannerInterface
type FileScanner struct {
        fs       afero.Fs
        database db.DBInterface
}

// NewFileScanner creates a new FileScanner instance
func NewFileScanner(fs afero.Fs, database db.DBInterface) *FileScanner <span class="cov8" title="1">{
        return &amp;FileScanner{
                fs:       fs,
                database: database,
        }
}</span>

// ScanDirectory scans a directory and indexes file metadata into the database
func (s *FileScanner) ScanDirectory(ctx context.Context, rootDir string, options *ScanOptions) (*ScanStats, error) <span class="cov8" title="1">{
        // Initialize DB
        if err := s.database.InitDB(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>
        <span class="cov8" title="1">defer s.database.Close() // Ensure DB connection is closed

        skipPatterns := utils.GetSkipPatterns()
        stats := &amp;ScanStats{}

        fmt.Printf("Starting scan of directory: %s\n", rootDir)
        if options.Verbose </span><span class="cov8" title="1">{
                fmt.Printf("Skip patterns: %v\n", skipPatterns)
        }</span>

        <span class="cov8" title="1">if utils.IsRunningAsRoot() </span><span class="cov0" title="0">{
                fmt.Printf("üîê Running with elevated privileges\n")
        }</span>

        <span class="cov8" title="1">err := afero.Walk(s.fs, rootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                // Check for context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // Handle permission errors gracefully
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        if utils.IsPermissionError(err) </span><span class="cov0" title="0">{
                                stats.PermissionErrors++
                                stats.SkippedPaths = append(stats.SkippedPaths, path)
                                if options.Verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("‚ö†Ô∏è  Permission denied, skipping: %s\n", path)
                                }</span>
                                <span class="cov0" title="0">return nil</span> // Continue walking, skip this path
                        }
                        <span class="cov8" title="1">return err</span> // Return other errors
                }

                // Skip special directories (even when running as root, unless verbose)
                <span class="cov8" title="1">if info.IsDir() &amp;&amp; utils.ShouldSkipPath(path, skipPatterns) </span><span class="cov8" title="1">{
                        // When running as root, still skip system directories unless explicitly verbose
                        if !utils.IsRunningAsRoot() || !options.Verbose </span><span class="cov8" title="1">{
                                stats.DirectoriesSkipped++
                                stats.SkippedPaths = append(stats.SkippedPaths, path)
                                if options.Verbose </span><span class="cov8" title="1">{
                                        fmt.Printf("‚è≠Ô∏è  Skipping special directory: %s\n", path)
                                }</span>
                                <span class="cov8" title="1">return filepath.SkipDir</span>
                        }
                }

                // Process files
                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                        // CPU ÏÇ¨Ïö©Îüâ Ï†úÏñ¥Î•º ÏúÑÌïú Ï£ºÍ∏∞Ï†ÅÏù∏ ÏßÄÏó∞
                        if options.ThrottleDelay &gt; 0 &amp;&amp; stats.FilesIndexed%100 == 0 </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return ctx.Err()</span>
                                case &lt;-time.After(options.ThrottleDelay):<span class="cov8" title="1"></span>
                                }
                        }

                        // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ Î∞è Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò
                        <span class="cov8" title="1">if stats.FilesIndexed%1000 == 0 </span><span class="cov8" title="1">{
                                var m runtime.MemStats
                                runtime.ReadMemStats(&amp;m)
                                if m.Alloc &gt; 100*1024*1024 </span><span class="cov0" title="0">{ // 100MB Ï¥àÍ≥ºÏãú GC Í∞ïÏ†ú Ïã§Ìñâ
                                        runtime.GC()
                                }</span>
                        }

                        <span class="cov8" title="1">if options.Verbose </span><span class="cov8" title="1">{
                                fmt.Printf("üìÅ Indexing: %s\n", path)
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Printf("Indexing: %s\n", path)
                        }</span>

                        // ÌååÏùº ÌÅ¨Í∏∞ ÌôïÏù∏ ÌõÑ Ìï¥Ïãú Í≥ÑÏÇ∞
                        <span class="cov8" title="1">var hash string
                        if options.MaxFileSize &gt; 0 &amp;&amp; info.Size() &gt; options.MaxFileSize </span><span class="cov0" title="0">{
                                // ÌÅ∞ ÌååÏùºÏùÄ Ìï¥Ïãú Í≥ÑÏÇ∞ Í±¥ÎÑàÎõ∞Í∏∞
                                hash = "large_file_skipped"
                                if options.Verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("‚è≠Ô∏è  File too large for hashing: %s (%d bytes)\n", path, info.Size())
                                }</span>
                        } else<span class="cov8" title="1"> {
                                var err error
                                hash, err = s.calculateFileHash(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        // Log the error but continue scanning other files
                                        if utils.IsPermissionError(err) </span><span class="cov0" title="0">{
                                                stats.PermissionErrors++
                                                if options.Verbose </span><span class="cov0" title="0">{
                                                        fmt.Printf("‚ö†Ô∏è  Permission denied for file %s, skipping\n", path)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                fmt.Fprintf(os.Stderr, "Could not hash file %s: %v\n", path, err)
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }
                        }

                        <span class="cov8" title="1">file := &amp;db.File{
                                Path:       path,
                                Name:       info.Name(),
                                Size:       info.Size(),
                                ModifiedAt: info.ModTime(),
                                FileHash:   hash,
                        }

                        if err := s.database.UpsertFile(file); err != nil </span><span class="cov8" title="1">{
                                fmt.Fprintf(os.Stderr, "Could not index file %s: %v\n", path, err)
                        }</span> else<span class="cov8" title="1"> {
                                stats.FilesIndexed++
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error walking the path %s: %w", rootDir, err)
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// calculateFileHash calculates the SHA-256 hash of a file with optimized reading
func (s *FileScanner) calculateFileHash(filePath string) (string, error) <span class="cov8" title="1">{
        file, err := s.fs.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        hash := sha256.New()

        // CPU Î∂ÄÌïòÎ•º Ï§ÑÏù¥Í∏∞ ÏúÑÌï¥ Ï≤≠ÌÅ¨ Îã®ÏúÑÎ°ú ÏùΩÍ∏∞ (32KB Î≤ÑÌçº)
        buffer := make([]byte, 32*1024)
        for </span><span class="cov8" title="1">{
                n, err := file.Read(buffer)
                if n &gt; 0 </span><span class="cov8" title="1">{
                        hash.Write(buffer[:n])
                }</span>
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // ÌÅ∞ ÌååÏùºÏùò Í≤ΩÏö∞ CPU ÏÇ¨Ïö©ÎüâÏùÑ Ï§ÑÏù¥Í∏∞ ÏúÑÌï¥ Ïû†Ïãú ÎåÄÍ∏∞
                <span class="cov8" title="1">runtime.Gosched()</span> // Îã§Î•∏ Í≥†Î£®Ìã¥ÏóêÍ≤å Ïã§Ìñâ Í∏∞Ìöå Ï†úÍ≥µ
        }

        <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package utils

import (
        "path/filepath"
        "runtime"
        "strings"
)

// GetSkipPatterns returns a list of directory patterns to skip based on the OS
func GetSkipPatterns() []string <span class="cov8" title="1">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov8" title="1"> // macOS
                return []string{
                        ".Trash", ".Trashes",
                        ".fseventsd",
                        ".Spotlight-V100",
                        ".DocumentRevisions-V100",
                        ".TemporaryItems",
                        ".DS_Store",
                        "System/Library",
                        "Library/Caches",
                        "private/var/vm",
                }</span>
        case "linux":<span class="cov0" title="0">
                return []string{
                        ".cache", ".local/share/Trash",
                        "proc", "sys", "dev",
                        "tmp", "var/tmp",
                        "run", "mnt",
                }</span>
        case "windows":<span class="cov0" title="0">
                return []string{
                        "$Recycle.Bin",
                        "System Volume Information",
                        "pagefile.sys",
                        "hiberfil.sys",
                        "swapfile.sys",
                }</span>
        default:<span class="cov0" title="0">
                return []string{".Trash", ".cache", "tmp"}</span>
        }
}

// ShouldSkipPath checks if a path should be skipped based on patterns
func ShouldSkipPath(path string, skipPatterns []string) bool <span class="cov8" title="1">{
        pathBase := filepath.Base(path)

        for _, pattern := range skipPatterns </span><span class="cov8" title="1">{
                if strings.Contains(path, pattern) || pathBase == pattern </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Skip hidden directories in root level scans (but allow deeper hidden files)
        <span class="cov8" title="1">if strings.HasPrefix(pathBase, ".") &amp;&amp; strings.Count(path, string(filepath.Separator)) &lt;= 3 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright ¬© 2025 changheonshin
*/
package utils

import (
        "fmt"
        "os"
        "os/exec"
        "runtime"
        "strings"
        "syscall"

        "github.com/spf13/cobra"
)

// IsRunningAsRoot checks if the current process is running with root privileges
func IsRunningAsRoot() bool <span class="cov8" title="1">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // On Windows, check if running as administrator
                // This is a simplified check - in production you might want more robust detection
                return false // For now, we'll skip sudo functionality on Windows
        }</span>
        <span class="cov8" title="1">return os.Geteuid() == 0</span>
}

// IsPermissionError checks if an error is a permission error
func IsPermissionError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for syscall.Errno permission errors
        <span class="cov8" title="1">if errno, ok := err.(syscall.Errno); ok </span><span class="cov8" title="1">{
                return errno == syscall.EACCES || errno == syscall.EPERM
        }</span>

        // Check for string-based permission errors
        <span class="cov8" title="1">errStr := err.Error()
        return strings.Contains(errStr, "permission denied") ||
                strings.Contains(errStr, "operation not permitted") ||
                strings.Contains(errStr, "access is denied")</span>
}

// RunWithSudo re-executes the current command with sudo privileges
func RunWithSudo(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return fmt.Errorf("sudo functionality is not supported on Windows")
        }</span>

        <span class="cov0" title="0">fmt.Println("üîê Requesting elevated privileges...")
        fmt.Println("‚ö†Ô∏è  WARNING: You are about to run fman with sudo privileges.")
        fmt.Print("   Continue? (y/N): ")

        var response string
        fmt.Scanln(&amp;response)
        if strings.ToLower(response) != "y" &amp;&amp; strings.ToLower(response) != "yes" </span><span class="cov0" title="0">{
                fmt.Println("Operation cancelled.")
                return nil
        }</span>

        // Get the current executable path
        <span class="cov0" title="0">executable, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get executable path: %w", err)
        }</span>

        // Build the sudo command
        <span class="cov0" title="0">sudoArgs := []string{executable, "scan"}
        sudoArgs = append(sudoArgs, args...)

        // Add other flags except --force-sudo to avoid infinite recursion
        verbose, _ := cmd.Flags().GetBool("verbose")
        if verbose </span><span class="cov0" title="0">{
                sudoArgs = append(sudoArgs, "--verbose")
        }</span>

        // Execute with sudo
        <span class="cov0" title="0">sudoCmd := exec.Command("sudo", sudoArgs...)
        sudoCmd.Stdout = os.Stdout
        sudoCmd.Stderr = os.Stderr
        sudoCmd.Stdin = os.Stdin

        return sudoCmd.Run()</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright ¬© 2025 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package main

import "github.com/devlikebear/fman/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
